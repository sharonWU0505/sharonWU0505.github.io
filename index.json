[{"body":"","link":"https://sharonwu0505.github.io/docs/","title":"Posts"},{"body":"Hi, I'm Sharon. I'm a frontend engineer from Taipei.\nThese days I build web app with React. I create platforms, campaign websites, and administration systems at work.\nIn the past few years, I wrote Vue.js and Django. And since I studied in college, using Python to build tools is my interest.\nThis blog contains my notes for development, mostly are frontend things. Feel free to read and contact me if you would like to discuss more.\n  Email: yasyuanwu@gmail.com Bio: LinkedIn profile     ","link":"https://sharonwu0505.github.io/about/","title":"About Me"},{"body":"","link":"https://sharonwu0505.github.io/tags/javascript/","title":"JavaScript"},{"body":"","link":"https://sharonwu0505.github.io/tags/","title":"Tags"},{"body":"","link":"https://sharonwu0505.github.io/tags/typescript/","title":"TypeScript"},{"body":"此篇要來談談 TypeScript 通用型別 (Generic Types) 的用途，以及 interface 和型別別名 (Type Alias) 的使用差異。\n通用型別 (Generic Types) 有時我們想在具有多種型別可能的情況下重用 (reuse) 程式碼，例如以下這個例子：\nfunction identity(arg: number): number { return arg; } identify 函式收到參數 arg，並回傳該參數。如果想更有彈性地使用函式，比方說不限定參數型別，則我們可以使用 any：\nfunction identity(arg: any): any { return arg; } 但如此一來我們便無法限制回傳值的型別要等同輸入值的型別，這時正是使用通用型別的時機。\n我們使用 type variable T 來代表型別，限制了函式輸入和輸出值的型別必須相同：\nfunction identify\u0026lt;T\u0026gt;(arg: T): T { return arg; } 使用 type variable 時，因為無從事先得知變數的型別，所以無法操作屬性或方法，例如以下範例將會收到錯誤：\nfunction identify\u0026lt;T\u0026gt;(arg: T): T { console.log(arg.length); // error: Property 'length' does not exist on type return arg; } 不過如果是：\nfunction loggingIdentity\u0026lt;T\u0026gt;(args: T[]): T[] { console.log(args.length); return args; } 將不會有問題，因為 arrays of type T 確定有 length 屬性。\n通用型別當然也可以跟 interface, class, tuple 等搭配運用，詳細使用方式請見官方文件。\n介面 (Interface) 與型別別名 (Type Alias) 的異同 型別別名在使用上和 interface 非常相似。\n相似之處 type 和 interface 一樣可以用來定義物件格式：\ntype Animal = { name: string } type 可使用 intersections 延伸屬性（interface 則通常會使用 extends)\ntype Animal = { name: string } type Bear = Animal \u0026amp; { honey: boolean } const bear = getBear(); bear.name; bear.honey; 不同之處  Aliasing doesn’t actually create a new type - it creates a new name to refer to that type. Aliasing a primitive is not terribly useful, though it can be used as a form of documentation.\n 根據官方文件，type 看起來更推薦用在單純要表示偏靜態的資料格式之時：\n// declaration type GreetingLike = string | (() =\u0026gt; string) | MyGreeter; declare function greet(g: GreetingLike): void; // usage function getGreeting() { return \u0026quot;howdy\u0026quot;; } class MyGreeter extends Greeter { ... } greet(\u0026quot;hello\u0026quot;); greet(getGreeting); greet(new MyGreeter()); References  https://www.typescriptlang.org/ https://willh.gitbook.io/typescript-tutorial/ ","link":"https://sharonwu0505.github.io/docs/2021/typescript-generic-and-type/","title":"TypeScript: Generic Types and Type Alias"},{"body":"此篇繼續來看 TypeScript 的基本語法。\nAny 在 TypeScript 中，可用 any 來表示允許賦值是任意型別。\n如果使用普通型別，在賦值過程中改變型別是不被允許的，但如果是 any 型別，則允許。以下程式將能順利被編譯。\nlet myNumber: any = 'nine'; myNumber = 9; 型別推論 如果沒有明確地指定型別，那麼 TypeScript 會依照型別推論（Type Inference）的規則推斷出型別。例如：\nlet myNumber = 'nine'; myNumber = 9; 編譯以上程式碼會收到錯誤。原因是 TypeScript 遇到賦值時會推斷出變數的型別是 string，爾後重新賦值時不允許改變型別。\n但如果宣吿變數時沒有指定型別也沒有賦值，則它會被推斷成任意型別 (any)，所以以下程式碼會通過編譯。\nlet myNumber; myNumber = 'nine'; myNumber = 9; Array 宣告 Array 型別其實很單純：\n an array of number: number[] an array of string: string[]  const numArray: number[] = [1, 2, 3]; Union Types 聯合型別（Union Types）表示取值可以為多種型別中的一種。\nlet myNumber: string | number; myNumber = 'nine'; myNumber = 9; 當 TypeScript 不確定一個聯合型別的變數到底是哪一個型別時，我們只能存取所有型別裡共有的屬性或方法。\nfunction getLength(something: string | number): number { return something.length; // error: 因為 number 沒有 `length` 屬性 } function getLength(something: string | number): number { return something.toString(); // works } Enum (列舉) Enum 型別經常被用在變數值有一定範圍的場景，例如一週 7 天、篩選選項等等。\n我們用 enum 關鍵字來定義變數：\nenum Filters { ALL, ACTIVE, PAST_DUE, } 列舉的項目會被賦值從 0 開始遞增的數字，同時也會有數字到列舉值的反向對映，所以如果我們印出 Filters，會看到：\n{ '0': 'ALL', '1': 'ACTIVE', '2': 'PAST_DUE', ALL: 0, ACTIVE: 1, PAST_DUE: 2, } 我們可用 Filters.PAST_DUE 來取得列舉項目的值。\nEnum 還有更多應用，包括手動賦值、常數列舉等等，有興趣的話可再去閱讀官方文件。\nFunction 定義函式時，要使用 TypeScript 約束函式的輸入和輸出，例如：\nNormal Function function sum(num1: number, num2: number): number { return num1 + num2; } Arrow Function const sum = (num1: number, num2: number): number =\u0026gt; { return num1 + num2; } sum(1, 2); // works sum(1, 2, 3); // works: more arguments are ignored Optional Parameters 如果某參數為 optional，可用 ? 來處理：\nfunction f(x?: number) { // ... } f(); // OK f(10); // OK Interface 在 TypeScript 中，我們使用 interface 來定義物件 (object) 的型別或形狀。以下是一個簡單的例子：\ninterface Person { // interface naming 通常首字母是大寫 name: string; gender: string; } let Amy: Person = { name: 'Amy', age: 25 }; 可以使用 readonly property 來定義唯讀的物件屬性：\ninterface Person { readonly name: string; gender: string; } interface 的更多應用請見官方文件。\nReferences  https://www.typescriptlang.org/ https://willh.gitbook.io/typescript-tutorial/ ","link":"https://sharonwu0505.github.io/docs/2021/typescript-more/","title":"TypeScript: Any, Array, Union Types, Enum, Function, and Interface"},{"body":"眾所皆知，JavaScript 是一個「弱型別」的語言，意思是：\n 開發者在宣告變數時，不需要事先指定變數的型別 e.g. string, number, boolean, etc. JavaScript 會根據變數被賦予的值去判斷它的型別 某些情況下，JavaScript 會在背地裡執行「強制轉型」(coercion)，將變數轉換成可以處理的型別  弱型別的設計讓 JavaScript 撰寫起來更方便，但也因此經常衍生出許多開發者預料之外的行為。在較大型、多人協作的專案裡，開發者們逐漸轉向 TypeScript，以期能借用「強型別」的概念，預先有靜態的型別檢查，避免預期外的錯誤。\nTypeScript 是 JavaScript 型別的超集，它會被編譯成 JavaScript，並可被瀏覽器執行。目前是一個由微軟維護的開源專案。\n除了強型別在編譯階段發現錯誤的特性，撰寫 TypeScript 還有一些優點，包括：\n 型別系統作為變數和函式的定義，具有文件的功用，能增加程式碼的可讀性 增強了編譯器和 IDE 的功能，例如除錯、提示、自動完成等  而 TypeScript 當然也有缺點，例如：\n 有一定的學習成本，整合專案也需要一些時間，短期內會拉長開發時程 非所有第三方函式庫都已支援  不過整體而言，TypeScript 的使用比例都逐漸增加當中，實務上也已顯現出價值，所以還是值得一學。接下來將整理 TypeScript 的基礎。\n安裝 TypeScript 如果你使用 npm 作為 package 管理工具，那麼可以以下指令在全域安裝 tsc 指令：\nnpm install -g typescript 執行後，可透過 tsc --version 確認是否安裝成功。\n編譯 TypeScript 檔案 大部分以 TypeScript 編寫的檔案以 .ts 為檔名結尾（用 TypeScript 編寫 React 時，以 .tsx 為檔名結尾）。\n透過執行 TypeScript 檔案，例如：\ntsc myFile.ts 將會得到一編譯完成的 JavaScript (.js) 檔案，例如：myFile.js。\n如果想啟用 watch mode，可以透過 tsc myFile.ts -w 進行。\nPrimitive Types 由於 JavaScript 的資料型別分成原始型別 (primitive types) 和物件型別 (object types)，所以我們也以此分別介紹它們在 TypeScript 中的應用。\n最基本的 TypeScript 定義為：\nlet firstVar: type; 若在賦值時型別錯誤，預期會在 terminal 中看到錯誤。\nString, Number, and Boolean Primitive types 包括 string, number, boolean, null, undefined。\n我們可以透過以下定義一個型別為 string 的變數。定義其他型別的作法基本上相同。\nlet myString: string = \u0026quot;hello world\u0026quot; Null and Undefined null 和 undefined 就比較特別了，它們是所有型別的子型別。意思是型別為 null 或 undefined 的變數，可以被賦值給其他變數，例如：\nlet myUndefined: undefined = undefined; let myBoolean: boolean = myUndefined; Void 而 JavaScript 中沒有空值 (void) 的概念，不過在 TypeScript 中，可以用 void 表示沒有任何返回值的函式返回值，也可以用來宣告變數，但型別為 void 的變數只能被賦值為 null 或 undefined，所以沒什麼意義。\nfunction sayHello(): void { console.log(\u0026quot;hello\u0026quot;) } References  https://www.typescriptlang.org/ https://willh.gitbook.io/typescript-tutorial/ ","link":"https://sharonwu0505.github.io/docs/2021/typescript-intro/","title":"Introduction to TypeScript and Primitive Types"},{"body":"受到 前端工程師一定要會的 JS 觀念題 的啟發，也想來整理 JavaScript 的常見問題，期望自己未來能用更口語但又不失精確，且搭配範例的方式解釋出這些概念。\n先列出幾個常見問題，之後再慢慢補上自己的理解。\nQuestions  What is scope? What is the difference between var, const, and let on scopes?\n  What is hoisting? Do const and let have hoisting?\n  What are primitive types and object types for variables?\n  What is the difference between Map and Object?\n  What is IIFE?\n  What is closure?\n  What is prototype?\n  What is the difference between callback-hell, Promise, and async-await?\n","link":"https://sharonwu0505.github.io/docs/2021/js-questions/","title":"JavaScript Questions"},{"body":"","link":"https://sharonwu0505.github.io/tags/http/","title":"HTTP"},{"body":"之前總以為 same-site 的網站一定也是 same-origin，後來才發現並非如此，是兩個不同的定義。此篇將介紹 same-site 和 same-origin 的定義，讓往後與後端 RD 討論 cookie SameSite 和 Access-Control-Allow-Origin header 設定時能更順利。\nOrigin Origin (網域) 是 scheme (或稱 protocol)、hostname (或稱 domain)，和 port 的組合。\nhttps://www.example.com:443 以上方網址為例\n scheme 是 https hostname 是 www.example.com port 是 443  因此，網址 https:www.example.com:443/foo 的 origin 為 https:www.example.com:443。\n\u0026quot;same-origin\u0026quot; and \u0026quot;cross-origin\u0026quot; 有著同樣 origin 的網站會是 \u0026quot;same-origin\u0026quot;（同源）；其餘則為 \u0026quot;cross-origin\u0026quot; (跨域/跨來源)。\norigin A: https://www.example.com:443\n   origin B \u0026quot;same-origin\u0026quot; or \u0026quot;cross-origin\u0026quot; to origin A     https://www.evil.com:443 cross-origin: different domains   https://example.com:443 cross-origin: different subdomains   https://login.example.com:443 cross-origin: different subdomains   http://www.example.com:443 cross-origin: different schemes   https://www.example.com:80 cross-origin: different ports   https://www.example.com:443 same-origin: exact match   https://www.example.com same-origin: implicit port number (443) matches    跨來源資源共用（Cross-Origin Resource Sharing (CORS)）  當 user agent 請求一個不同源的資源時，會建立一個跨來源 HTTP 請求（cross-origin HTTP request）。基於安全性考量，跨來源 HTTP 請求會受到限制，例如 XMLHttpRequest 和 Fetch API 都遵守同源政策（same-origin policy）。這代表 API 除非使用 CORS 標頭，否則只能請求與應用程式相同網域的 HTTP 資源。\n 由於此篇著重比較 same-site 和 same-origin 的差別，所以若想知道更多跨來源資源共用的規範，請見 MDN Web Docs。\nSite (eTLD + 1) \u0026quot;Site\u0026quot; 是指 TLD (Top-level domain) 和它之前的 domain。TLDs 包含條列在 Root Zone Database 中的 domain，例如 .com 和 .org。\n以 https://www.example.com:443/foo 為例\n eTLD 是 .com site (eTLD + 1) 是 example.com eTLD 和 TLD 的差別下方會說明  不過也有另一類的 domain，像是 .co.jp 和 .github.io。這類 domain 如果只用 .jp 和 .io 作為 TLD 去定義 site 是不足夠的，而且也缺乏廣泛適用的邏輯去判斷。所以出現了表列的 eTLDs (effective TLDs)，被條列在 Mozilla Public Suffix List 中。site 也被稱為 eTLD + 1。\n以 https://my-project.github.io 為例\n eTLD 是 .github.io site (eTLD + 1) 是 my-project.github.io  \u0026quot;same-site\u0026quot; and \u0026quot;cross-site\u0026quot; 有相同 eTLD + 1 的網站為 \u0026quot;same-site\u0026quot;；其餘則為 \u0026quot;cross-site\u0026quot;。\nsite A: https://www.example.com:443\n   site B \u0026quot;same-site\u0026quot; or \u0026quot;cross-site\u0026quot; to site A     https://www.evil.com:443 cross-site: different domains   https://login.example.com:443 same-site: different subdomains don't matter   http://www.example.com:443 same-site: different schemes don't matter   https://www.example.com:80 same-site: different ports don't matter   https://www.example.com:443 same-site: exact match   https://www.example.com same-site: ports don't matter    而 cats.github.io 和 dogs.github.io 為 cross-site，因為它們的 eTLD + 1 不同。\n\u0026quot;schemeful same-site\u0026quot; 從上述的定義中可以知道，scheme 是否相同不影響 \u0026quot;same-site\u0026quot; 的判斷，但為了避免 HTTP 被以 weak channel 使用，協定開始商議將 scheme 納入判斷中，稱為 \u0026quot;schemeful same-site\u0026quot;。\n如此一來，https://www.example.com:443 和 http://www.example.com:443 便為 \u0026quot;cross-site\u0026quot;，因為它們的 scheme 不同。\nChrome 80 後針對第三方 cookie 的調整  Chrome 80+ 後將對所有未設定 SameSite 屬性的 Set-Cookie 預設為 SameSite=Lax，意味著除了 top level navigate + GET 的請求行為外，其餘 cross-site request 送發 cookie 的行為將預設被關閉。\n SiteSite values\n SameSite=None (with Secure) SameSite=Lax SameSite=Strict  更詳細的說明請見 Chrome 80 後針對第三方 Cookie 的規則調整\nHow to check if a request is \u0026quot;same-site\u0026quot;, \u0026quot;same-origin\u0026quot;, or \u0026quot;cross-site\u0026quot; 部分瀏覽器會在請求的 HTTP header 中附上 Sec-Fetch-Site 值，不過目前普及率不算高。\nSec-Fetch-Site 會是以下幾個值：\n cross-site same-site (沒區分 \u0026quot;schemeful same-site\u0026quot;) same-origin none  Reference  Understanding \u0026quot;same-site\u0026quot; and \u0026quot;same-origin\u0026quot; ","link":"https://sharonwu0505.github.io/docs/2021/same-site-and-same-origin/","title":"Same-Site and Same-Origin"},{"body":"開發時，經常會須要從另一台機器連接在 localhost 的網站，或是希望能有個 public URL 測試某些功能，例如：Facebook Open Graph 設置、Chatbot 連接、金流串接。這時就會想有沒有什麼比先部署到伺服器上再 debug 更方便的作法呢？\n有的，你可用 Ngrok！\nNgrok 是一個能將你的 localhost 網址對應到公開 http/https 連結的服務。背後的原理是 Ngrok 建立了一個 TCP 層上的 tunnel（本機內網和 Ngrok 雲端伺服器之間），處理需求轉發至你指定的 port。\n使用  Getting Started - Setup\n  Step 1: 註冊 Ngrok 帳號 Step 2: 安裝 Ngrok Step 3: 連結帳戶（Ngrok 會給你 access token） Step 4: 指定 port 開始使用，例如：  ./ngrok http 80  啟用後便可以看到連線資料 須注意每次拿到的連結都會不同  進階方案  Pricing\n Ngrok 也有個付費方案，提供客製 domain、每分鐘更多連線數、TLS tunnel 等服務。\n","link":"https://sharonwu0505.github.io/docs/2021/ngrok-intro/","title":"Introduction to Ngrok"},{"body":"","link":"https://sharonwu0505.github.io/tags/tools/","title":"Tools"},{"body":"","link":"https://sharonwu0505.github.io/tags/github-actions/","title":"GitHub Actions"},{"body":"","link":"https://sharonwu0505.github.io/tags/hugo/","title":"Hugo"},{"body":"接續以 Hugo 建立部落格，Hugo 在其文件中提到了多種 Hosting and Deployment 方式。若你選擇將 source code 放在 GitHub 上，那麼你可以直接考慮將部落格放在 GitHub Pages 上，並使用 GitHub Actions 自動化所有部署和更新的流程。\nStep 1: Create a Project on GitHub for the Blog 在 GitHub 上建立部落格 repository，並將 source code 都推上去。\n不該推的東西請加到 .gitignore 中\n resources .DS_Store  Step 2: 建立 GitHub Pages 如果你想建立 GitHub Pages，請按照說明在帳號下建立一個名為 your-username.github.io 的 repository。\nStep 3: 部署準備 Create GitHub token 在 GitHub Tokens Page 建立 personal access token，權限選擇 repo 和 workflow。建立完成後，請複製 token。\nAdd Access Token as Secrets 在部落格 repo 的 Settings \u0026gt; Secrets 頁面上，建立一 Repository secrets。\n Name: 可取你想要的 Value: 貼上剛剛複製的 token  Step 4: Create A GitHub Action  在部落格 repo 建立 .github/workflows 資料夾 資料夾下新增 main.yml，貼上以下 action 設置  name: CI on: push jobs: deploy: runs-on: ubuntu-18.04 steps: - name: Git checkout uses: actions/checkout@v2 - name: Update theme # (Optional) If you have the theme added as submodule, you can pull it and use the most updated version run: git submodule update --init --recursive - name: Setup hugo uses: peaceiris/actions-hugo@v2 # or change to a version you prefer with: hugo-version: \u0026quot;0.80.0\u0026quot; - name: Build # remove --minify tag if you do not need it # docs: https://gohugo.io/hugo-pipes/minification/ run: hugo --minify # replace TOKEN and username to your own settings - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.TOKEN }} external_repository: \u0026lt;username\u0026gt;/\u0026lt;username\u0026gt;.github.io publish_dir: ./public # keep_files: true user_name: \u0026lt;username\u0026gt; user_email: \u0026lt;username@email.com\u0026gt; publish_branch: main # cname: example.com Step 5: Push to GitHub Remote push 到 remote 後，你將會在 repo 的 Actions 頁面看到 action 的進度。等待 action 成功後，就可以在 https://\u0026lt;username\u0026gt;.github.io/ 看到部落格囉！\n Reference  GitHub Actions Hugo: Deploy Static Site using GitHub Actions ","link":"https://sharonwu0505.github.io/docs/2021/deploy-hugo-blog-to-github/","title":"自動化部署 Hugo 部落格到 GitHub Pages"},{"body":"Hugo 是一個用 Go 寫成的靜態網站生成器（Static Site Generator）。其架構允許以 Markdown 格式撰寫內容，再搭配 layout template 渲染出畫面，對於喜歡用 Markdown 簡潔撰寫文章的人來說很合適！\n就讓我們來看看如何以 Hugo 建立部落格，並在每次更新後自動化部署到 GitHub Pages。\nHugo 不管是「網站打包」還是「從零建立網站」的速度都很快，號稱\n The world’s fastest framework for building websites.\n 與類似的框架 Wordpress 和 Gatsby 一樣，Hugo 也有豐富多元且開源的主題 (theme)，讓人方便快速地就建立起自己的網站。\n此網站就是以 Hugo 建立的，並使用 Compose Theme 讓我們來看看是怎麼做的吧～\nGetting Started  Reference: Hugo - Quick Start, Compose - Install Theme\n  Step 1 - Install Hugo (for MacOS)  brew install hugo  Step 2 - New a Site  hugo new site my-blog  Step 3 - Install a theme  cd my-blog git init git submodule add https://github.com/onweru/compose/ themes/compose cp -a themes/compose/exampleSite/* .  Step 4 - Run Hugo Server  hugo server   Step 5 - Open http://localhost:1313/ in browser and then you'll see a site with the Compose theme\n  Step 6 - Add your content and customize the styles!\n  Directory Structure Hugo 有制式的檔案架構，若依照該架構放置內容，便能享有 Hugo 預設的功能，諸如：列表 (list page) 和單篇 (single page) 結構、多國語言、template 組合等等。以下介紹常見 Hugo 架構中各檔案夾的意義。\nmy-blog ├── archetypes ├── assets // scss and js to be processed by Hugo Pipes ├── content // 網站主要內容都維護在此 ├── layouts // 網站頁面樣式，因為我們有使用主題，如果需要客製化覆蓋主題的樣式，可在此新增檔案 ├── static // 放置網站圖片、CSS、JS 檔案 ├── theme // 主題 └── config.toml // 設定檔  Layout 覆蓋順序請見 Hugo's Lookup Order\n Deploy 請見下篇自動化部署 Hugo 部落格到 GitHub Pages\n","link":"https://sharonwu0505.github.io/docs/2021/build-a-blog-with-hugo/","title":"以 Hugo 建立部落格"},{"body":"","link":"https://sharonwu0505.github.io/tags/webview/","title":"WebView"},{"body":"本篇文章預計介紹什麼是 WebView，以及 Frontend 使用 WebView 時可能會遇到的問題。\nA WebView is an embeddable browser that a native application can use to display web content.\nConcepts  embeddable browser: WebView is developed based on engines used by common browsers such as Safari, Chrome, Firefox, Edge. It can just be viewed as a browser. native application: apps/games in our case display web content  commonly load web content from a http:// or https:// location JavaScript running inside the WebView also has the ability to call native system APIs.    常見的 WebView 應用  Facebook/Twitter/Line 的內建瀏覽器 App 內嵌入廣告（類似 Web 嵌入 iframe）  Why use WebView?  有助於 app 留存和 UX（不必跳出 app） 更新彈性較高：修改頁面 layout 或邏輯，只需修改網頁後重新部署。不須以推新版本，並要求使用者更新 app 的方式進行  Possible problems  瀏覽器支援程度  無法使用 alert(), confirm() 等，要以 WebChromeClient override methods (ref)   開發環境  比照一般網頁的開發方式 如果想看實際在 app 中開啟狀況，還是得將 app 以模擬器跑起來   UX 問題  WebView 的關閉按鈕可能會跟網頁設計的排版衝突 scroll、touch move 等事件，不一定和瀏覽器的效果相同，ex: scroll bouncing   能否判斷網頁是否是以 WebView 開啟？  判斷 user agent (ref) 保險一點 app 開 WebView 時設定 user agent   身份驗證流程，ex: token 存取，也涉及 UX  連接和 App 相同的伺服器？ 視為 App 的延伸並從 App 獲取部分資料？    References  https://www.kirupa.com/apps/webview.htm https://docs.uniwebview.com/ 查 WebView 大多都是 app 相關的開發文章，事實上使用 WebView 的話，frontend 也不太需要做什麼處理 ","link":"https://sharonwu0505.github.io/docs/2021/what-is-webview/","title":"What is WebView?"},{"body":"","link":"https://sharonwu0505.github.io/tags/prettier/","title":"Prettier"},{"body":"Prettier is an opinionated code formatter supporting several languages. The biggest reason for adopting Prettier is to stop all the on-going debates over styles. Therefore, applying Prettier to frontend development flow can save much time on formatting codes and align coding styles.\nIn my opinion, ESLint and Prettier are must tools for every frontend projects (not only personal, but also group ones).\nPrettier vs. Linters Linters have two categories of rules:\n Formatting rules: eg: max-len, no-mixed-spaces-and-tabs, keyword-spacing, comma-style, … Code-quality rules: eg: no-unused-vars, no-extra-bind, no-implicit-globals, prefer-promise-reject-errors, …  Prettier covers all needs of formatting codes, but it does nothing with checking code qualities. In other words, use Prettier for formatting and linters for catching bugs!\nUsage Global Settings  Install: npm install -g prettier@2.2.1  should lock the version, because default rules differ by releases check the version: npm list -g prettier   Create a .prettierrc file  cd (to root path) touch .prettierrc   Add rules to ~/.prettierrc  open the file: open ~/.prettierrc add following lines and save it    { \u0026quot;printWidth\u0026quot;: 100, \u0026quot;tabWidth\u0026quot;: 2, \u0026quot;semi\u0026quot;: true, \u0026quot;trailingComma\u0026quot;: \u0026quot;es5\u0026quot;, \u0026quot;jsxBracketSameLine\u0026quot;: true }  (optional) Create a .prettierignore file Format certain files: prettier --write ${file-path-or-pattern}  Integrate with VSCode  Install Prettier - Code formatter plugin (is using prettier@2.2.1) Open settings.json, add following lines and save it Format current file: cmd+shift+p \u0026gt; Format Document  For Prettier \u0026quot;editor.defaultFormatter\u0026quot;: \u0026quot;esbenp.prettier-vscode\u0026quot;, \u0026quot;editor.formatOnSave\u0026quot;: true, // default Other Settings \u0026quot;editor.rulers\u0026quot;: [ 100 ], \u0026quot;editor.tabSize\u0026quot;: 2, // optional \u0026quot;editor.renderWhitespace\u0026quot;: \u0026quot;boundary\u0026quot;, // recommended \u0026quot;javascript.updateImportsOnFileMove.enabled\u0026quot;: \u0026quot;always\u0026quot;, // recommended Local Settings by Projects If a project has its own Prettier config file, the configuration will be applied. Prettier searches recursively up the file path, it will fallback to global settings if local configuration is not found.\nConfiguration  See options  References  https://prettier.io/ https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode https://hackmd.io/@chupai/HkNT0IMhr ","link":"https://sharonwu0505.github.io/docs/2020/setting-prettier/","title":"Setting Prettier to Format Codes"},{"body":"","link":"https://sharonwu0505.github.io/tags/workflow/","title":"Workflow"},{"body":"","link":"https://sharonwu0505.github.io/tags/eslint/","title":"ESLint"},{"body":"Linting tools like ESLint allow developers to discover problems with their JavaScript code without executing it.\n讓我們來談談如何以 ESLint 改進前端開發流程，且如何挑選 ESLint。\nESLint can\n To find code problems To find patterns that doesn’t adhere to style guides Integrate with editors and CI pipeline to auto-check  More ESlint can do\n Customize linting rules Fix many problems automatically  What is the difference between linters and prettier?\n See Setting Prettier to Format Codes  Select Guides Must have  eslint:recommended plugin:react/recommended  More rules selected  Best practices  [error] default-case [error] default-case-last (for version \u0026gt;= 7.0) [error] default-param-last (conflicts with Redux reducer) [warn] eqeqeq [warn] no-empty-function [warn] no-extra-bind   Stylistic issues  [warn] max-depth: 4 [warn] max-len: 100 [warn] no-multiple-empty-lines: max 2 lines [warn] no-trailing-spaces: ignore comments   React  [error] react/no-access-state-in-setstate   React Hook  [error] react-hooks/rules-of-hooks [warn] react-hooks/exhaustive-deps     Integrate with React Projects Integrating ESLint with React project helps us to find problems and stick to coding guidelines.\nInstallation  If you used create-react-app to start a project, ESLint is already provided. It's highly recommended to extend the default configuration.  Install eslint-plugin-react and eslint-plugin-react-hooks Add .eslintrc and customize settings    Customize ESLint Configuration for Project Bootstrapped by Create-React-App  Step 1: extend ESlint  run touch .env at project root add EXTEND_ESLINT=true to .env   Step 2: install React related ESlint config  run npm install eslint-plugin-react --save-dev run npm install eslint-plugin-react-hooks --save-dev   Step 3: set .eslintrc  run touch .eslintrc at project root remove \u0026quot;eslintConfig\u0026quot; settings in package.json add the following to the file    { \u0026quot;env\u0026quot;: { \u0026quot;browser\u0026quot;: true, \u0026quot;commonjs\u0026quot;: true, \u0026quot;es2020\u0026quot;: true, \u0026quot;node\u0026quot;: true }, \u0026quot;extends\u0026quot;: [ // \u0026quot;react-app\u0026quot;, // will cause cannot find eslint error \u0026quot;eslint:recommended\u0026quot;, \u0026quot;plugin:react/recommended\u0026quot; ], \u0026quot;parserOptions\u0026quot;: { \u0026quot;ecmaFeatures\u0026quot;: { \u0026quot;jsx\u0026quot;: true }, \u0026quot;ecmaVersion\u0026quot;: 11, \u0026quot;sourceType\u0026quot;: \u0026quot;module\u0026quot; }, \u0026quot;plugins\u0026quot;: [ \u0026quot;react\u0026quot;, \u0026quot;react-hooks\u0026quot; ], \u0026quot;rules\u0026quot;: { \u0026quot;default-case\u0026quot;: \u0026quot;error\u0026quot;, \u0026quot;eqeqeq\u0026quot;: \u0026quot;warn\u0026quot;, \u0026quot;no-unused-vars\u0026quot;: [\u0026quot;warn\u0026quot; , { \u0026quot;vars\u0026quot;: \u0026quot;all\u0026quot;, \u0026quot;args\u0026quot;: \u0026quot;after-used\u0026quot;, \u0026quot;argsIgnorePattern\u0026quot;: \u0026quot;^_\u0026quot; }], \u0026quot;no-empty-function\u0026quot;: \u0026quot;warn\u0026quot;, \u0026quot;no-extra-bind\u0026quot;: \u0026quot;warn\u0026quot;, \u0026quot;max-depth\u0026quot;: \u0026quot;warn\u0026quot;, \u0026quot;max-len\u0026quot;: [ \u0026quot;warn\u0026quot;, { \u0026quot;code\u0026quot;: 100 } ], \u0026quot;no-multiple-empty-lines\u0026quot;: \u0026quot;warn\u0026quot;, \u0026quot;no-trailing-spaces\u0026quot;: [ \u0026quot;warn\u0026quot;, { \u0026quot;ignoreComments\u0026quot;: true, \u0026quot;skipBlankLines\u0026quot;: true } ], \u0026quot;react/no-access-state-in-setstate\u0026quot;: \u0026quot;error\u0026quot;, \u0026quot;react-hooks/rules-of-hooks\u0026quot;: \u0026quot;error\u0026quot;, \u0026quot;react-hooks/exhaustive-deps\u0026quot;: \u0026quot;warn\u0026quot; } } 備註  We hide react-app in extends and set eslint:recommended by ourselves. If the settings do not work  delete node_modules run npm install again   若沒有使用 React Hook，不必加上 Hook 相關的 lint   Integrate with VSCode  Install extension ESLint Add following lines to VSCode settings.json  \u0026quot;eslint.lintTask.enable\u0026quot;: true, \u0026quot;eslint.workingDirectories\u0026quot;: \u0026quot;./\u0026quot;, // based on your project structure  References  Popular style guides and ESlint config  Airbnb JavaScript Style Guide（較嚴謹）  eslint-config-airbnb   Google JavaScript Style Guide Javascript Standard Style（較寬鬆）   ","link":"https://sharonwu0505.github.io/docs/2020/setting-eslint/","title":"Setting ESLint to Enhance Frontend Development"},{"body":"","link":"https://sharonwu0505.github.io/tags/react/","title":"React"},{"body":"在寫 React component 時會須要確認 props 是否符合型別和資料結構，以確保 component 能如預期運作。除了用 Flow 或 TypeScript 去檢查型別之外，React 本身也提供 propTypes 屬性用以檢查拿到的 props。在 function 和 class component 上都可以使用。\n不只上述好處，個人認為定義 propTypes 也能讓 component 的 interface 更為清楚，使其他開發者一眼就知道該傳入的 props，有類似文件的作用。\n以下內容大多翻譯自 React 文件：Typechecking With PropTypes\n 須注意為了避免效能問題，propTypes 檢查只發生在開發模式。 如果發生錯誤，會在 console 中看到警告\n Install props-types 自 React v15.5 後，React.PropTypes 被移出到獨立的 library，因此若要使用須額外安裝。\nnpm install prop-types --save Supported PropTypes  Basic data types  PropTypes.any PropTypes.bool  PropTypes.number PropTypes.string  PropTypes.func PropTypes.array PropTypes.object PropTypes.symbol   Renderable types  PropTypes.node : the prop should be anything that can be rendered by React  PropTypes.element: the prop should be a React element   也有其他更精確的 operator 可以用，亦能傳入 expression  instanceOf oneOf oneOfType arrayOf shape   有能定義是否為 required  isRequired    Example (同理 function component) import PropTypes from \u0026quot;prop-types\u0026quot;; class ReactComponent extends React.Component { // ...component class body here } ReactComponent.propTypes = { // ...props-type definitions here } Default Prop Values 也可以給予 props defaultProps。型別檢查會在 defaultProps 賦予 props 值之後，所以型別檢查也會作用在 defaultProps 上。\nclass ReactComponent extends React.Component { render() { return ( \u0026lt;div\u0026gt;Hello, {this.props.name}\u0026lt;/div\u0026gt; ) } } ReactComponent.defaultProps = { name: \u0026quot;stranger\u0026quot;, } Reference  PropTypes in React: A complete guide ","link":"https://sharonwu0505.github.io/docs/2020/react-props-types/","title":"Validating React Component Props with props-types"},{"body":"","link":"https://sharonwu0505.github.io/tags/golang/","title":"Golang"},{"body":"Go or called GoLang is an open source programming language that makes it easy to build simple, reliable, and efficient software.\nIn this post, we'll talk about how to install Golang and set its workplace. Also, sub directories under the workplace are introduced.\nInstall Go  For MacOS, using Homebrew  brew install go Set Go Workplace  A workspace is Go’s way to facilitate project management.\n  A workspace in nutshell, is a directory on your system where Go looks for source code files, manages dependency packages and build distribution binary files. You can have as many workspaces as you want, as long as you keep GOPATH environment variable pointed to current working workspace directory.\n  Reference: Getting started with Go\n Default Workplace $HOME/go Customize Your Go Workplace Permanently  bash  open file: open ~/.bash_profile edit file: add export GOPATH=$HOME/\u0026lt;customized-path\u0026gt;/go to the file reload: source ~/.bash_profile   zsh  open file: open ~/.zshrc edit file: add export GOPATH=$HOME/\u0026lt;customized-path\u0026gt;/go to the file reload: source ~/.zshrc   others  see SettingGOPATH    Temporarily  For MacOS  see Setting up Environment Variables in MacOS Sierra     Sub Directories under a Go Workplace src  Containing packages (also packages installed by go get command) Whenever working with a new Go project, a new directory for the project should be created under $GOPATH/src.  pkg  Containing Go package objects, which are compiled version of original package source code When a Go program hits import statement, Go looks for the followings in order.  pre-compiled package object corresponded packages in $GOPATH/src corresponded packages in $GOROOT/src    bin  Containing binary executable files for executing Go programs, which are created by go install commands $GOBIN is an environment variable that Go uses to put binary files. By default, $GOBIN is $GOPATH/bin but you can change it, too. ","link":"https://sharonwu0505.github.io/docs/2020/install-and-set-go/","title":"Install Golang and Set Go Workplace"},{"body":"之前遇到 網頁各語言有各自 open graph 設定 的需求，所以決定寫一篇文章介紹什麼是 open graph，以及紀錄 Single Page Application (SPA) 如何實現多國語言之 og tag 設置。\nThe Open Graph Protocol  The Open Graph protocol enables any web page to become a rich object in a social graph. For instance, this is used on Facebook to allow any web page to have the same functionality as any other object on Facebook. source: https://ogp.me/\n  OG tags are used to decide how you website looks on SNS. Different SNS (ex: Facebook, Twitter) has its own og rules, but most tags used are the same. To turn your web pages into graph objects, you need to add basic metadata to your page.  我們在 Twitter 張貼連結時會看到附圖、標題、說明等內容，即是 open graph 功能的顯現。\nBasic Metadata   Facebook - A Guide to Sharing for Webmasters Twitter - Cards   Required meta data  og:title: 文章的標題 og:type: 內容的媒體類型 og:image: 用戶分享內容時顯示的圖像網址 og:url: 網頁的標準網址  Optional meta data  og:description: 內容的簡短說明 og:locale: 資源的地區設定 og:locale:alternate og:determiner og:audio og:video  Example \u0026lt;meta property=\u0026quot;og:type\u0026quot; content=\u0026quot;article\u0026quot; /\u0026gt; \u0026lt;meta property=\u0026quot;og:title\u0026quot; content=\u0026quot;title to show on SNS\u0026quot; /\u0026gt; \u0026lt;meta property=\u0026quot;og:description\u0026quot; content=\u0026quot;describe your website\u0026quot; /\u0026gt; \u0026lt;meta property=\u0026quot;og:image\u0026quot; content=\u0026quot;thumbnail for website\u0026quot; /\u0026gt; \u0026lt;meta property=\u0026quot;og:url\u0026quot; content=\u0026quot;your website's link\u0026quot; /\u0026gt;  Debug Tools 設置 open graph tag 後，如果想測試，可使用以下 debug tools\n Enter the site URL (should be public URL) to preview share dialog on SNS  Facebook share debugger Twitter card validator     Limitations  Open graph meta tags cannot be altered dynamically and the url of the page is constant regardless of search result. For SPA, all pages are developed from a single index.html file, so all pages share the same og tags.  Solution to Build Multi-languages OG Tags 1. Build multiple static pages for SNS crawlers\n Source: Single Page Applications and Open Graph\n  Create pages only for og crawlers, which only contain og meta data and a script to redirect back to the SPA.  {site_url}/zh.html {site_url}/en.html   Send those pages based on languages when sharing for og crawlers to get og tags.  2. Use Server-Side-Rendering (SSR) or Isomorphic\n React.js with Next.js 大致概念為第一次頁面渲染使用 SSR，後續操作維持 CSR ","link":"https://sharonwu0505.github.io/docs/2020/multi-lang-og-tags/","title":"Building Multi-Languages OG Tags"},{"body":"","link":"https://sharonwu0505.github.io/tags/open-graph/","title":"Open Graph"},{"body":"","link":"https://sharonwu0505.github.io/tags/seo/","title":"SEO"},{"body":"認識 cookie 的筆記。\nCookie  An HTTP cookie (web cookie, browser cookie) is a small piece of data that a server sends to the user's web browser. The browser may store it and send it back with the next request to the same server. It is one of the methods available for remembering stateful information for the stateless HTTP protocol.\n Purposes  Session management: logins, shopping carts, game scores, etc. Personalization: User preferences, themes, etc. Tracking: recording and analyzing user behavior  Limitations and Alternatives  Cookies are sent with every request, so they can worsen performance (especially for mobile data connections). Modern APIs for client storage are the Web storage API (localStorage and sessionStorage) and IndexedDB.   Creating Cookies  Each cookie is a key=value pair. When receiving an HTTP request, a server can send a Set-Cookie header with the response.  HTTP/2.0 200 OK Content-type: text/html Set-Cookie: \u0026lt;cookie-name\u0026gt;=\u0026lt;cookie-value\u0026gt;;\u0026lt;cookie-name\u0026gt;=\u0026lt;cookie-value\u0026gt;  The cookie is usually stored by the browser, and then the cookie is sent with requests made to the same server inside a Cookie HTTP header.  GET /sample_page.html HTTP/2.0 Host: www.example.org Cookie: \u0026lt;cookie-name\u0026gt;=\u0026lt;cookie-value\u0026gt;;\u0026lt;cookie-name\u0026gt;=\u0026lt;cookie-value\u0026gt;  Cookie Keys  Secure HttpOnly SameSite  SameSite=None  The browser will send cookies with both cross-site requests and same-site requests.   SameSite=Strict  The browser will only send cookies for same-site requests (requests originating from the site that set the cookie).   SameSite=Lax  Same-site cookies are withheld on cross-site subrequests, such as calls to load images or frames, but will be sent when a user navigates to the URL from an external site; for example, by following a link.      SameSite Cookie Changes  Chrome 80 released in February 2020 adopted new policy for SameSite to prevent Cross Site Request Forgery (CSRF). ","link":"https://sharonwu0505.github.io/docs/2020/cookie/","title":"Introduction to Cookie"},{"body":"What is npm and nvm?  npm (Node Package Manager)  JavaScript 套件庫管理工具，可以藉由它下載各式各樣的套件   nvm (Node Version Manager)  各套件和專案用的 Node.js 版本不同，而版本間有不相容的問題，導致套件和專案無法順利運行，因此需要版本管理工具 從 nvm 下載/更換 Node.js 和 npm 版本    Install nvm (for MacOS)  Install nvm using Homebrew  brew install nvm  Add nvm command to shell  echo \u0026quot;source $(brew --prefix nvm)/nvm.sh\u0026quot; \u0026gt;\u0026gt; .bash_profile  Reload the bashprofile file  . ~/.bash_profile or\nsource ~/.bash_profile  If using zsh, need to add command to zshrc  open ~/.zshrc Add source ~/.bash_profile to file, which means load all commands under bashprofile   Check if installation is successful  nvm --version \u0026gt; Example output: 0.35.1 or\ncommand -v nvm \u0026gt; output: nvm Install Node.js and npm by nvm  Check available remote version  nvm ls-remote  Install preferred version  nvm install \u0026lt;version\u0026gt;  Use specific version  nvm use \u0026lt;version\u0026gt; \u0026gt; Example output: Now using node v10.17.0 (npm v6.11.3)  See available local versions  nvm list ","link":"https://sharonwu0505.github.io/docs/2020/nvm-and-npm/","title":"Introduction to NVM and NPM"},{"body":"","link":"https://sharonwu0505.github.io/tags/npm/","title":"npm"},{"body":"","link":"https://sharonwu0505.github.io/categories/","title":"Categories"},{"body":"To Find Frontend, and to Feel!\n","link":"https://sharonwu0505.github.io/","title":"Draw Closer"}]