[{"body":"","link":"https://sharonwu0505.github.io/docs/","title":"Posts"},{"body":"Hi, I'm Sharon. I'm a software engineer from Taipei, Taiwan.\nThese days I develop large-scale cloud security platform mainly by Angular and PHP. I also have much experience on React for building interactive campaign websites and internal administration systems.\nIn the past few years, I wrote Python and Django. And since then, using Python to boost routine works became one of my interest.\nThis blog contains my notes for software development, mostly are frontend things. I'm stepping into backend now, so hopefully there'll have more related to it in the future.\nFeel free to read and contact me if you would like to discuss more.\n  Email: yasyuanwu@gmail.com Bio: LinkedIn profile     ","link":"https://sharonwu0505.github.io/about/","title":"About Me"},{"body":"","link":"https://sharonwu0505.github.io/tags/angular/","title":"Angular"},{"body":"寫網頁的過程中免不了一定會出現「表單」，Angular 提供兩種不同的表單建立方式來處理使用者輸入，分別是 reactive forms 和 template-driven forms。\n兩種方式都能夠\n 抓取使用者在 view 上的 input events 驗證使用者輸數 建立 form model 和 data model 給後續表單資料更新 建議一套追蹤表單資料變化的機制  而本文將介紹兩種方式的異同和使用方式。\nChoosing an approach 兩種方式的關鍵差異可由下張表來描述\n    REACTIVE TEMPLATE-DRIVEN     Setup of form model Explicit, created in component class Implicit, created by directives   Data model Structured and immutable Unstructured and mutable   Data flow Synchronous Asynchronous   Form validation Functions Directives    因為 reactive form 提供直接對接底層的 form API，且 view 和 data model 的更新為同步的，測試時較不須要處理 change detection 問題，因此當我們要建立 large-scale 或複雜的表單時，使用上會比 templare-driven form 來得方便。\nSetting up the form model Reactive and template-driven forms 共用 building blocks 來追蹤使用者與 form input 元素的互動以及 component 裡的 form data 變化。兩種方式只差別在開發者如何建立和管理 form-control instances。\nCommon form foundation classes  FormControl tracks the value and validation status of an individual form control. FormGroup tracks the same values and status for a collection of form controls. FormArray tracks the same values and status for an array of form controls. ControlValueAccessor creates a bridge between Angular FormControl instances and built-in DOM elements.  Setup in reactive forms (1) Register the reactive forms module\n1import { Component } from \u0026#39;@angular/core\u0026#39;; 2import { FormControl } from \u0026#39;@angular/forms\u0026#39;; 3 4@Component({ 5 selector: \u0026#39;app-reactive-favorite-color\u0026#39;, 6 template: ` 7\u0026lt;!-- (3) Register the control in the template --\u0026gt; 8Favorite Color: \u0026lt;input type=\u0026#34;text\u0026#34; [formControl]=\u0026#34;favoriteColorControl\u0026#34;\u0026gt; 9` 10}) 11export class FavoriteColorComponent { 12 favoriteColorControl = new FormControl(\u0026#39;\u0026#39;); // (2) Generate a new FormControl 13} 更多常見的使用：\n 使用 FormGroup 建立巢狀表單欄位 使用 setValue() 方法更改單一 FormControl 的值 使用 patchValue() 方法一次更新多個 FormControl 的值 使用 FormBuilder service 使建立表單更容易，不必自行重複處理 form group 和 form control 使用 FormArray 動態建立長度不固定的 unamed FormControl  在 reactive form 中，form model（FormControl instance）是真相來源。它透過 [formControl] directive 與 template input element 綁定，提供表單元素的值和狀態。\nSetup in template-driven forms 1import { Component } from \u0026#39;@angular/core\u0026#39;; 2 3@Component({ 4 selector: \u0026#39;app-template-favorite-color\u0026#39;, 5 template: ` 6Favorite Color: \u0026lt;input type=\u0026#34;text\u0026#34; [(ngModel)]=\u0026#34;favoriteColor\u0026#34;\u0026gt; 7` 8}) 9export class FavoriteColorComponent { 10 favoriteColor = \u0026#39;\u0026#39;; 11} 在 template-driven form 中，form model 是隱含的，是 direcive NgModel 為 input element 建立並管理了 FormControl instance。\n在此方式中，template 是真相來源，開發者沒有辦法直接修改 FormControl instance。\nData flow in forms Reactive 和 template-driven forms 處理 view 和 component model 資料更新的流程不同。\nData flow in reactive forms 在 reactive forms 中，view 中的表單元素都直接與 form model 相連（a FormControl instance）。 從 view 到 model 以及從 model 到 view 的更新是同步的，而且不依賴於 UI 是如何渲染的。\nHow the data flows when an input field's is changed from the view:  The user types a value into the input element, in this case the favorite color Blue. The form input element emits an \u0026quot;input\u0026quot; event with the latest value. The control value accessor listening for events on the form input element immediately relays the new value to the FormControl instance. The FormControl instance emits the new value through the valueChanges observable. Any subscribers to the valueChanges observable receive the new value.  How the data flows when a programmatic change to the model is propagated to the view:  The user calls the favoriteColorControl.setValue() method, which updates the FormControl value. The FormControl instance emits the new value through the valueChanges observable. Any subscribers to the valueChanges observable receive the new value. The control value accessor on the form input element updates the element with the new value.  Data flow in template-driven forms How data flows when an input field's value is changed from the view:  The user types Blue into the input element. The input element emits an \u0026quot;input\u0026quot; event with the value Blue. The control value accessor attached to the input triggers the setValue() method on the FormControl instance. The FormControl instance emits the new value through the valueChanges observable. Any subscribers to the valueChanges observable receive the new value. The control value accessor also calls the NgModel.viewToModelUpdate() method which emits an ngModelChange event. Because the component template uses two-way data binding for the favoriteColor property, the favoriteColor property in the component is updated to the value emitted by the ngModelChange event (Blue).  How data flows from model to view when the favoriteColor changes from Blue to Red:  The favoriteColor value is updated in the component. Change detection begins. During change detection, the ngOnChanges lifecycle hook is called on the NgModel directive instance because the value of one of its inputs has changed. The ngOnChanges() method queues an async task to set the value for the internal FormControl instance. Change detection completes. On the next tick, the task to set the FormControl instance value is executed. The FormControl instance emits the latest value through the valueChanges observable. Any subscribers to the valueChanges observable receive the new value. The control value accessor updates the form input element in the view with the latest favoriteColor value.  Mutability of the data model  Reactive forms 中的資料是 immutable 的，每次 data model 有所改變，FormControl instance 都會回傳一個新的 data model 而不是更新現有的。這也讓 change detection 較有效率。 Template-driven forms 則基於 two-way data binding 在 template 有任何改變時去更新 component data model。  References  Angular - Introduction to Forms ","link":"https://sharonwu0505.github.io/docs/2022/angular-forms/","title":"Angular Forms - Reactive Forms and Template-Driven Forms"},{"body":"","link":"https://sharonwu0505.github.io/tags/","title":"Tags"},{"body":"撰寫 Angular templates 時一定會用到 ng-template 和 ngTemplateOutlet 來實現進階的功能，而它們經常與 ng-container 搭配使用。\n我們將基於 Angular ng-template, ng-container and ngTemplateOutlet - The Complete Guide To Angular Templates 這篇寫得非常好的文章來介紹它們的用途和使用方式。\nng-template Directive 顧名思義，ng-template directive 代表一段 Angular template，它們可以和其他 templates 組合成最終的 component template。ng-template 其實被廣泛應用在 Angular 自身的 structural directives, e.g. ngIf, ngFor, ngSwitch 當中。\n如果我們今天撰寫一段 ng-template：\n1@Component({ 2 selector: \u0026#39;app-root\u0026#39;, 3 template: ` 4\u0026lt;ng-template\u0026gt; 5\u0026lt;button class=\u0026#34;tab-button\u0026#34; (click)=\u0026#34;login()\u0026#34;\u0026gt;{{loginText}}\u0026lt;/button\u0026gt; 6\u0026lt;button class=\u0026#34;tab-button\u0026#34; (click)=\u0026#34;signUp()\u0026#34;\u0026gt;{{signUpText}}\u0026lt;/button\u0026gt; 7\u0026lt;/ng-template\u0026gt; 8`}) 9export class AppComponent { 10 loginText = \u0026#39;Login\u0026#39;; 11 signUpText = \u0026#39;Sign Up\u0026#39;; 12 lessons = [\u0026#39;Lesson 1\u0026#39;, \u0026#39;Lessons 2\u0026#39;]; 13 14 login() { 15 console.log(\u0026#39;Login\u0026#39;); 16 } 17 18 signUp() { 19 console.log(\u0026#39;Sign Up\u0026#39;); 20 } 21} 大家注意到的第一件事應該會是以上程式碼並沒有 render 任何東西到畫面中。因為 ng-template 只是單純用來定義 template，而我們尚未使用它。\nThe ng-template Directive and ngIf 1\u0026lt;div class=\u0026#34;lessons-list\u0026#34; *ngIf=\u0026#34;lessons else loading\u0026#34;\u0026gt; 2 ... 3\u0026lt;/div\u0026gt; 4 5\u0026lt;ng-template #loading\u0026gt; 6 \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt; 7\u0026lt;/ng-template\u0026gt; 這是一個最常見的例子。我們透過定義 loading (#loading) 為 template reference，在沒有 lessons 資料時顯示 loading template。這段程式碼實際上會被 Angular 解讀為以下形式：\n1\u0026lt;ng-template [ngIf]=\u0026#34;lessons\u0026#34; [ngIfElse]=\u0026#34;loading\u0026#34;\u0026gt; 2 \u0026lt;div class=\u0026#34;lessons-list\u0026#34;\u0026gt; 3 ... 4 \u0026lt;/div\u0026gt; 5\u0026lt;/ng-template\u0026gt; 6 7\u0026lt;ng-template #loading\u0026gt; 8 \u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt; 9\u0026lt;/ng-template\u0026gt; 此轉換也見於 ngFor 和 ngSwitch，這也是為什麼我們無法使用多個 structural directives 在同一元素上的原因，Angular 無法順利將它們解讀成 implicit ng-template 的格式。\n如果要使用多個 structural directives 我們可以這樣寫：\n1\u0026lt;div *ngIf=\u0026#34;lessons\u0026#34;\u0026gt; 2 \u0026lt;div class=\u0026#34;lesson\u0026#34; *ngFor=\u0026#34;let lesson of lessons\u0026#34;\u0026gt; 3 \u0026lt;div class=\u0026#34;lesson-detail\u0026#34;\u0026gt; 4 {{lesson | json}} 5 \u0026lt;/div\u0026gt; 6 \u0026lt;/div\u0026gt; 7\u0026lt;/div\u0026gt; 不過你應該會想問：可以不要有多餘的 div 嗎？答案是可以的，而正是 ng-container 讓我們可以這麼做！\nng-container Directive 1\u0026lt;ng-container *ngIf=\u0026#34;lessons\u0026#34;\u0026gt; 2 \u0026lt;div class=\u0026#34;lesson\u0026#34; *ngFor=\u0026#34;let lesson of lessons\u0026#34;\u0026gt; 3 \u0026lt;div class=\u0026#34;lesson-detail\u0026#34;\u0026gt; 4 {{lesson | json}} 5 \u0026lt;/div\u0026gt; 6 \u0026lt;/div\u0026gt; 7\u0026lt;/ng-container\u0026gt; ng-container 使我們得以在不必生成多餘元素的情況下，將由 structural directive 控制的元素附帶到畫面上。而它也能用來動態地注入 (inject) template 到畫面，一樣是透過 template reference #loading，並藉由 ngTemplateOutlet directive，我們能在頁面任何地方實例化 template。\n1\u0026lt;ng-container *ngTemplateOutlet=\u0026#34;loading\u0026#34;\u0026gt;\u0026lt;/ng-container\u0026gt; Template Context 這時衍生出一個關鍵的問題：template 有自己的 variable scope 嗎？template 能取用哪些變數呢？\nng-template instances 能取得它們被內嵌 (embedded) 之處的 context，像是之前的例子中，我們能在 ng-template 裡面使用 lessons。然而各個 template 亦可定義它們自己的 context object。\n1@Component({ 2 selector: \u0026#39;app-root\u0026#39;, 3 template: ` 4\u0026lt;ng-template #estimateTemplate let-lessonsCounter=\u0026#34;estimate\u0026#34;\u0026gt; 5\u0026lt;div\u0026gt; Approximately {{lessonsCounter}} lessons ...\u0026lt;/div\u0026gt; 6\u0026lt;/ng-template\u0026gt; 7\u0026lt;ng-container *ngTemplateOutlet=\u0026#34;estimateTemplate;context:ctx\u0026#34;\u0026gt;\u0026lt;/ng-container\u0026gt; 8`}) 9export class AppComponent { 10 totalEstimate = 10; 11 ctx = {estimate: this.totalEstimate}; 12} Template 中我們以 prefix let- 定義它的 property lessonsCounter，此變數可在 template 中使用。而變數的 context 來自於一個在實例化時跟著 template 一起傳給 ngTemplateOutlet 的 context object。\n除了在 template 中使用 ng-template，我們也能在 component level 經由 template references 跟 template 互動。\nTemplate References 我們用 ViewChild decorator 把 template 直接地注入到 component。\n1@Component({ 2 selector: \u0026#39;app-root\u0026#39;, 3 template: ` 4\u0026lt;ng-template #defaultTabButtons\u0026gt; 5\u0026lt;button class=\u0026#34;tab-button\u0026#34; (click)=\u0026#34;login()\u0026#34;\u0026gt;{{loginText}}\u0026lt;/button\u0026gt; 6\u0026lt;button class=\u0026#34;tab-button\u0026#34; (click)=\u0026#34;signUp()\u0026#34;\u0026gt;{{signUpText}}\u0026lt;/button\u0026gt; 7\u0026lt;/ng-template\u0026gt; 8`}) 9export class AppComponent implements OnInit { 10 @ViewChild(\u0026#39;defaultTabButtons\u0026#39;) 11 private defaultTabButtonsTpl: TemplateRef\u0026lt;any\u0026gt;; 12 13 ngOnInit() { 14 console.log(this.defaultTabButtonsTpl); 15 } 16} 由於能在 component 中取得 template，我們就能將該 template 傳遞給 child components。\n這常見於當我們想建立更客製化的 component，我們不只傳遞 configuration parameter 或 configuration object，我們亦能將 template 作為 input parameter。\nParent Component: AppComponent 1@Component({ 2 selector: \u0026#39;app-root\u0026#39;, 3 template: ` 4\u0026lt;ng-template #customTabButtons\u0026gt; 5\u0026lt;div class=\u0026#34;custom-class\u0026#34;\u0026gt; 6\u0026lt;button class=\u0026#34;tab-button\u0026#34; (click)=\u0026#34;login()\u0026#34;\u0026gt;{{loginText}}\u0026lt;/button\u0026gt; 7\u0026lt;button class=\u0026#34;tab-button\u0026#34; (click)=\u0026#34;signUp()\u0026#34;\u0026gt;{{signUpText}}\u0026lt;/button\u0026gt; 8\u0026lt;/div\u0026gt; 9\u0026lt;/ng-template\u0026gt; 10\u0026lt;tab-container [headerTemplate]=\u0026#34;customTabButtons\u0026#34;\u0026gt;\u0026lt;/tab-container\u0026gt; 11`}) 12export class AppComponent implements OnInit {} Child Component TabContainerComponent 在沒有 input headerTemplate 時，render defaultTabButtons：\n1@Component({ 2 selector: \u0026#39;tab-container\u0026#39;, 3 template: ` 4\u0026lt;ng-template #defaultTabButtons\u0026gt; 5\u0026lt;div class=\u0026#34;default-tab-buttons\u0026#34;\u0026gt; 6... 7\u0026lt;/div\u0026gt; 8\u0026lt;/ng-template\u0026gt; 9\u0026lt;ng-container *ngTemplateOutlet=\u0026#34;headerTemplate ? headerTemplate: defaultTabButtons\u0026#34;\u0026gt;\u0026lt;/ng-container\u0026gt; 10... rest of tab container component ... 11`}) 12export class TabContainerComponent { 13 @Input() 14 headerTemplate: TemplateRef\u0026lt;any\u0026gt;; 15} 以上就是關於 ng-template、ng-container 和 ngTemplateOutlet 的介紹，希望有讓大家更理解它們能做到什麼事。\n","link":"https://sharonwu0505.github.io/docs/2021/angular-advanced-templates/","title":"Angular Advanced Templates - ng-template, ng-container and ngTemplateOutlet"},{"body":"","link":"https://sharonwu0505.github.io/tags/javascript/","title":"JavaScript"},{"body":"受到 前端工程師一定要會的 JS 觀念題 的啟發，也想來整理 JavaScript 的常見問題，期望自己未來能用更口語但又不失精確，且搭配範例的方式解釋出這些概念。\n第一部分一樣以 What is ...? 為主，會先列出幾個常見問題，之後再慢慢補上自己的理解。\nQuestions  What is scope? What is the difference between var, const, and let on scopes?\n  What is hoisting? Do const and let have hoisting?\n  What are primitive types and object types for variables?\n  What is IIFE (Immediately Invoked Function Expression)?\n IIFE is a JavaScript function which is executed right after it is defined.\nAn IIFE is composed by two parts:\n (1) an anonymous function wrapped by the grouping operator (), by which variables in the function will not pollute the global environment (2) an expression () for executing the function  (function () { var aName = \u0026quot;Barry\u0026quot;; })(); // Variable name is not accessible from the outside scope aName; // throws \u0026quot;Uncaught ReferenceError: aName is not defined\u0026quot; IIFE is also a common design pattern. If you check codes bundled by Webpack, we'll see a lot of IIFE. IIFE prevents creating unnecessary global variables and having naming conflicts, thus it makes benefits on maintaining codes.\n What is closure?\n  What is prototype?\n","link":"https://sharonwu0505.github.io/docs/2021/js-questions-1/","title":"WIP: JavaScript Questions (1)"},{"body":"最近由於工作需要開始學習 Angular，過程中發現雖然 Angular 也是 component-based 的 SPA (Single Page Application) 框架，卻多了一層 Module (模組) 的概念。若是從 React 過來的開發者，可能會對這個概念有點陌生，所以我們就來看看 Angular Modules 是什麼吧～\nBasics Angular 應用是模組化的，它的模組系統叫做 NgModules。其實 NgModules 的定義和作用與大家經常在程式設計中聽到的模組/模組化相去不遠，它是由數個具備基礎功能的元件所組成的特定功能組件，經過組合 (composition) 形成具有完整功能的系統或程式。\nNgModules 系統與 JavaScript（ES2015/ES6）用來處理 JavaScript 物件的模組系統（import \u0026amp; export）不同，也沒有直接的關聯。但這兩種系統互補，撰寫 Angular 的過程中一定會共同使用兩者。\n以 Angular 的設計來說，一個應用至少會有一個 NgModule class，也就是 Root Module（根模組）。基於開發習慣，root module 通常會被命名為 AppModule，並被定義在 app.module.ts 中。如果要啟用 Angular 應用，那麼就要 bootstrap root module。\n一個 Angular module 包含 components, service providers 等其他要在該 module 下作用的程式檔案。Module 可以引用其他 module 匯出的功能，也可以匯出指定功能讓其他 module 使用。\nNgModule Metadata 我們使用被 @NgModule() decorator 裝飾的 class 來定義 NgModule。 @NgModule() 是一個接收單一 metadata JavaScript object 的函式，object 描述了 module 的屬性，以下介紹各屬性的用途：\n declarations: scope 屬於此 module 的 components、directives 和 pipes exports: 能在其他模組之 component templates 中被使用的 declarations 的子集 imports: 那些匯出此 module 的 component templates 所需 classes 的 module providers: 此 module 向 global services 貢獻的 service creators，能被應用中的任何部分使用。也可以在 component-level 再指名 providers。 bootstrap: 應用中的 main application view，又稱為 Root Component，是應用中其他 views 的 host (宿主)。只有 root NgModule 需要有此 bootstrap 屬性。  這是一個簡單的 root NgModule 範例：\n1import { NgModule } from \u0026#39;@angular/core\u0026#39;; 2import { BrowserModule } from \u0026#39;@angular/platform-browser\u0026#39;; 3 4@NgModule({ 5 imports: [ BrowserModule ], // BrowserModule is for connecting to DOM. 6 providers: [ Logger ], 7 declarations: [ AppComponent ], 8 exports: [ AppComponent ], // In reality, we don\u0026#39;t need to export here, because no any other modules will need to import root module. 9 bootstrap: [ AppComponent ] 10}) 11export class AppModule { } NgModules and Components 那麼 module 和 component 之間的關係是什麼呢？\nNgModule 為它的 components 提供一個 compilation context（編譯上下文環境）。Root module 總會有一個 root component，也能再包含任意數量的其他 components，他們會共享一個 compilation context*。*\n而 component 和 component template 組成 view，view 能具有階層結構（hierarchy），此結構可以混合使用由不同 NgModule 中的 component 定義的 view。\n如上圖所示，此 view 階層由來自兩個 NgModule（由藍色和橘色區分）的 views 組合而成。\nReferences  Introduction to Angular concepts Introduction to modules NgModule 簡介 ","link":"https://sharonwu0505.github.io/docs/2021/angular-intro-to-modules/","title":"Angular - Introduction to Modules"},{"body":"","link":"https://sharonwu0505.github.io/tags/typescript/","title":"TypeScript"},{"body":"此篇要來談談 TypeScript 通用型別 (Generic Types) 的用途，以及 interface 和型別別名 (Type Alias) 的使用差異。\n通用型別 (Generic Types) 有時我們想在具有多種型別可能的情況下重用 (reuse) 程式碼，例如以下這個例子：\n1function identity(arg: number): number { 2 return arg; 3} identify 函式收到參數 arg，並回傳該參數。如果想更有彈性地使用函式，比方說不限定參數型別，則我們可以使用 any：\n1function identity(arg: any): any { 2 return arg; 3} 但如此一來我們便無法限制回傳值的型別要等同輸入值的型別，這時正是使用通用型別的時機。\n我們使用 type variable T 來代表型別，限制了函式輸入和輸出值的型別必須相同：\n1function identify\u0026lt;T\u0026gt;(arg: T): T { 2 return arg; 3} 使用 type variable 時，因為無從事先得知變數的型別，所以無法操作屬性或方法，例如以下範例將會收到錯誤：\n1function identify\u0026lt;T\u0026gt;(arg: T): T { 2 console.log(arg.length); // error: Property \u0026#39;length\u0026#39; does not exist on type 3 return arg; 4} 不過如果是：\n1function loggingIdentity\u0026lt;T\u0026gt;(args: T[]): T[] { 2 console.log(args.length); 3 return args; 4} 將不會有問題，因為 arrays of type T 確定有 length 屬性。\n通用型別當然也可以跟 interface, class, tuple 等搭配運用，詳細使用方式請見官方文件。\n介面 (Interface) 與型別別名 (Type Alias) 的異同 型別別名在使用上和 interface 非常相似。\n相似之處 type 和 interface 一樣可以用來定義物件格式：\n1type Animal = { 2 name: string 3} type 可使用 intersections 延伸屬性（interface 則通常會使用 extends)\n1type Animal = { 2 name: string 3} 4 5type Bear = Animal \u0026amp; { 6 honey: boolean 7} 8 9const bear = getBear(); 10bear.name; 11bear.honey; 不同之處  Aliasing doesn’t actually create a new type - it creates a new name to refer to that type. Aliasing a primitive is not terribly useful, though it can be used as a form of documentation.\n 根據官方文件，type 看起來更推薦用在單純要表示偏靜態的資料格式之時：\n1// declaration 2type GreetingLike = string | (() =\u0026gt; string) | MyGreeter; 3 4declare function greet(g: GreetingLike): void; 5 6// usage 7function getGreeting() { 8 return \u0026#34;howdy\u0026#34;; 9} 10 11class MyGreeter extends Greeter { 12 ... 13} 14 15greet(\u0026#34;hello\u0026#34;); 16greet(getGreeting); 17greet(new MyGreeter()); References  https://www.typescriptlang.org/ https://willh.gitbook.io/typescript-tutorial/ ","link":"https://sharonwu0505.github.io/docs/2021/typescript-generic-and-type/","title":"TypeScript: Generic Types and Type Alias"},{"body":"此篇繼續來看 TypeScript 的基本語法。\nAny 在 TypeScript 中，可用 any 來表示允許賦值是任意型別。\n如果使用普通型別，在賦值過程中改變型別是不被允許的，但如果是 any 型別，則允許。以下程式將能順利被編譯。\n1let myNumber: any = \u0026#39;nine\u0026#39;; 2myNumber = 9; 型別推論 如果沒有明確地指定型別，那麼 TypeScript 會依照型別推論（Type Inference）的規則推斷出型別。例如：\n1let myNumber = \u0026#39;nine\u0026#39;; 2myNumber = 9; 編譯以上程式碼會收到錯誤。原因是 TypeScript 遇到賦值時會推斷出變數的型別是 string，爾後重新賦值時不允許改變型別。\n但如果宣吿變數時沒有指定型別也沒有賦值，則它會被推斷成任意型別 (any)，所以以下程式碼會通過編譯。\n1let myNumber; 2myNumber = \u0026#39;nine\u0026#39;; 3myNumber = 9; Array 宣告 Array 型別其實很單純：\n an array of number: number[] an array of string: string[]  1const numArray: number[] = [1, 2, 3]; Union Types 聯合型別（Union Types）表示取值可以為多種型別中的一種。\n1let myNumber: string | number; 2myNumber = \u0026#39;nine\u0026#39;; 3myNumber = 9; 當 TypeScript 不確定一個聯合型別的變數到底是哪一個型別時，我們只能存取所有型別裡共有的屬性或方法。\n1function getLength(something: string | number): number { 2 return something.length; // error: 因為 number 沒有 `length` 屬性 3} 1function getLength(something: string | number): number { 2 return something.toString(); // works 3} Enum (列舉) Enum 型別經常被用在變數值有一定範圍的場景，例如一週 7 天、篩選選項等等。\n我們用 enum 關鍵字來定義變數：\n1enum Filters { 2 ALL, 3 ACTIVE, 4 PAST_DUE, 5} 列舉的項目會被賦值從 0 開始遞增的數字，同時也會有數字到列舉值的反向對映，所以如果我們印出 Filters，會看到：\n1{ 2 \u0026#39;0\u0026#39;: \u0026#39;ALL\u0026#39;, 3 \u0026#39;1\u0026#39;: \u0026#39;ACTIVE\u0026#39;, 4 \u0026#39;2\u0026#39;: \u0026#39;PAST_DUE\u0026#39;, 5 ALL: 0, 6 ACTIVE: 1, 7 PAST_DUE: 2, 8} 我們可用 Filters.PAST_DUE 來取得列舉項目的值。\nEnum 還有更多應用，包括手動賦值、常數列舉等等，有興趣的話可再去閱讀官方文件。\nFunction 定義函式時，要使用 TypeScript 約束函式的輸入和輸出，例如：\nNormal Function 1function sum(num1: number, num2: number): number { 2 return num1 + num2; 3} Arrow Function 1const sum = (num1: number, num2: number): number =\u0026gt; { 2 return num1 + num2; 3} 4 5sum(1, 2); // works 6sum(1, 2, 3); // works: more arguments are ignored Optional Parameters 如果某參數為 optional，可用 ? 來處理：\n1function f(x?: number) { 2 // ... 3} 4 5f(); // OK 6f(10); // OK Interface 在 TypeScript 中，我們使用 interface 來定義物件 (object) 的型別或形狀。以下是一個簡單的例子：\n1interface Person { // interface naming 通常首字母是大寫 2 name: string; 3 gender: string; 4} 5 6let Amy: Person = { 7 name: \u0026#39;Amy\u0026#39;, 8 age: 25 9}; 可以使用 readonly property 來定義唯讀的物件屬性：\n1interface Person { 2 readonly name: string; 3 gender: string; 4} interface 的更多應用請見官方文件。\nReferences  https://www.typescriptlang.org/ https://willh.gitbook.io/typescript-tutorial/ ","link":"https://sharonwu0505.github.io/docs/2021/typescript-more/","title":"TypeScript: Any, Array, Union Types, Enum, Function, and Interface"},{"body":"眾所皆知，JavaScript 是一個「弱型別」的語言，意思是：\n 開發者在宣告變數時，不需要事先指定變數的型別 e.g. string, number, boolean, etc. JavaScript 會根據變數被賦予的值去判斷它的型別 某些情況下，JavaScript 會在背地裡執行「強制轉型」(coercion)，將變數轉換成可以處理的型別  弱型別的設計讓 JavaScript 撰寫起來更方便，但也因此經常衍生出許多開發者預料之外的行為。在較大型、多人協作的專案裡，開發者們逐漸轉向 TypeScript，以期能借用「強型別」的概念，預先有靜態的型別檢查，避免預期外的錯誤。\nTypeScript 是 JavaScript 型別的超集，它會被編譯成 JavaScript，並可被瀏覽器執行。目前是一個由微軟維護的開源專案。\n除了強型別在編譯階段發現錯誤的特性，撰寫 TypeScript 還有一些優點，包括：\n 型別系統作為變數和函式的定義，具有文件的功用，能增加程式碼的可讀性 增強了編譯器和 IDE 的功能，例如除錯、提示、自動完成等  而 TypeScript 當然也有缺點，例如：\n 有一定的學習成本，整合專案也需要一些時間，短期內會拉長開發時程 非所有第三方函式庫都已支援  不過整體而言，TypeScript 的使用比例都逐漸增加當中，實務上也已顯現出價值，所以還是值得一學。接下來將整理 TypeScript 的基礎。\n安裝 TypeScript 如果你使用 npm 作為 package 管理工具，那麼可以以下指令在全域安裝 tsc 指令：\nnpm install -g typescript 執行後，可透過 tsc --version 確認是否安裝成功。\n編譯 TypeScript 檔案 大部分以 TypeScript 編寫的檔案以 .ts 為檔名結尾（用 TypeScript 編寫 React 時，以 .tsx 為檔名結尾）。\n透過執行 TypeScript 檔案，例如：\ntsc myFile.ts 將會得到一編譯完成的 JavaScript (.js) 檔案，例如：myFile.js。\n如果想啟用 watch mode，可以透過 tsc myFile.ts -w 進行。\nPrimitive Types 由於 JavaScript 的資料型別分成原始型別 (primitive types) 和物件型別 (object types)，所以我們也以此分別介紹它們在 TypeScript 中的應用。\n最基本的 TypeScript 定義為：\n1let firstVar: type; 若在賦值時型別錯誤，預期會在 terminal 中看到錯誤。\nString, Number, and Boolean Primitive types 包括 string, number, boolean, null, undefined。\n我們可以透過以下定義一個型別為 string 的變數。定義其他型別的作法基本上相同。\n1let myString: string = \u0026#34;hello world\u0026#34; Null and Undefined null 和 undefined 就比較特別了，它們是所有型別的子型別。意思是型別為 null 或 undefined 的變數，可以被賦值給其他變數，例如：\n1let myUndefined: undefined = undefined; 2let myBoolean: boolean = myUndefined; Void 而 JavaScript 中沒有空值 (void) 的概念，不過在 TypeScript 中，可以用 void 表示沒有任何返回值的函式返回值，也可以用來宣告變數，但型別為 void 的變數只能被賦值為 null 或 undefined，所以沒什麼意義。\n1function sayHello(): void { 2 console.log(\u0026#34;hello\u0026#34;) 3} References  https://www.typescriptlang.org/ https://willh.gitbook.io/typescript-tutorial/ ","link":"https://sharonwu0505.github.io/docs/2021/typescript-intro/","title":"Introduction to TypeScript and Primitive Types"},{"body":"","link":"https://sharonwu0505.github.io/tags/http/","title":"HTTP"},{"body":"之前總以為 same-site 的網站一定也是 same-origin，後來才發現並非如此，是兩個不同的定義。此篇將介紹 same-site 和 same-origin 的定義，讓往後與後端 RD 討論 cookie SameSite 和 Access-Control-Allow-Origin header 設定時能更順利。\nOrigin Origin (網域) 是 scheme (或稱 protocol)、hostname (或稱 domain)，和 port 的組合。\nhttps://www.example.com:443 以上方網址為例\n scheme 是 https hostname 是 www.example.com port 是 443  因此，網址 https:www.example.com:443/foo 的 origin 為 https:www.example.com:443。\n\u0026quot;same-origin\u0026quot; and \u0026quot;cross-origin\u0026quot; 有著同樣 origin 的網站會是 \u0026quot;same-origin\u0026quot;（同源）；其餘則為 \u0026quot;cross-origin\u0026quot; (跨域/跨來源)。\norigin A: https://www.example.com:443\n   origin B \u0026quot;same-origin\u0026quot; or \u0026quot;cross-origin\u0026quot; to origin A     https://www.evil.com:443 cross-origin: different domains   https://example.com:443 cross-origin: different subdomains   https://login.example.com:443 cross-origin: different subdomains   http://www.example.com:443 cross-origin: different schemes   https://www.example.com:80 cross-origin: different ports   https://www.example.com:443 same-origin: exact match   https://www.example.com same-origin: implicit port number (443) matches    跨來源資源共用（Cross-Origin Resource Sharing (CORS)）  當 user agent 請求一個不同源的資源時，會建立一個跨來源 HTTP 請求（cross-origin HTTP request）。基於安全性考量，跨來源 HTTP 請求會受到限制，例如 XMLHttpRequest 和 Fetch API 都遵守同源政策（same-origin policy）。這代表 API 除非使用 CORS 標頭，否則只能請求與應用程式相同網域的 HTTP 資源。\n 由於此篇著重比較 same-site 和 same-origin 的差別，所以若想知道更多跨來源資源共用的規範，請見 MDN Web Docs。\nSite (eTLD + 1) \u0026quot;Site\u0026quot; 是指 TLD (Top-level domain) 和它之前的 domain。TLDs 包含條列在 Root Zone Database 中的 domain，例如 .com 和 .org。\n以 https://www.example.com:443/foo 為例\n eTLD 是 .com site (eTLD + 1) 是 example.com eTLD 和 TLD 的差別下方會說明  不過也有另一類的 domain，像是 .co.jp 和 .github.io。這類 domain 如果只用 .jp 和 .io 作為 TLD 去定義 site 是不足夠的，而且也缺乏廣泛適用的邏輯去判斷。所以出現了表列的 eTLDs (effective TLDs)，被條列在 Mozilla Public Suffix List 中。site 也被稱為 eTLD + 1。\n以 https://my-project.github.io 為例\n eTLD 是 .github.io site (eTLD + 1) 是 my-project.github.io  \u0026quot;same-site\u0026quot; and \u0026quot;cross-site\u0026quot; 有相同 eTLD + 1 的網站為 \u0026quot;same-site\u0026quot;；其餘則為 \u0026quot;cross-site\u0026quot;。\nsite A: https://www.example.com:443\n   site B \u0026quot;same-site\u0026quot; or \u0026quot;cross-site\u0026quot; to site A     https://www.evil.com:443 cross-site: different domains   https://login.example.com:443 same-site: different subdomains don't matter   http://www.example.com:443 same-site: different schemes don't matter   https://www.example.com:80 same-site: different ports don't matter   https://www.example.com:443 same-site: exact match   https://www.example.com same-site: ports don't matter    而 cats.github.io 和 dogs.github.io 為 cross-site，因為它們的 eTLD + 1 不同。\n\u0026quot;schemeful same-site\u0026quot; 從上述的定義中可以知道，scheme 是否相同不影響 \u0026quot;same-site\u0026quot; 的判斷，但為了避免 HTTP 被以 weak channel 使用，協定開始商議將 scheme 納入判斷中，稱為 \u0026quot;schemeful same-site\u0026quot;。\n如此一來，https://www.example.com:443 和 http://www.example.com:443 便為 \u0026quot;cross-site\u0026quot;，因為它們的 scheme 不同。\nChrome 80 後針對第三方 cookie 的調整  Chrome 80+ 後將對所有未設定 SameSite 屬性的 Set-Cookie 預設為 SameSite=Lax，意味著除了 top level navigate + GET 的請求行為外，其餘 cross-site request 送發 cookie 的行為將預設被關閉。\n SiteSite values\n SameSite=None (with Secure) SameSite=Lax SameSite=Strict  更詳細的說明請見 Chrome 80 後針對第三方 Cookie 的規則調整\nHow to check if a request is \u0026quot;same-site\u0026quot;, \u0026quot;same-origin\u0026quot;, or \u0026quot;cross-site\u0026quot; 部分瀏覽器會在請求的 HTTP header 中附上 Sec-Fetch-Site 值，不過目前普及率不算高。\nSec-Fetch-Site 會是以下幾個值：\n cross-site same-site (沒區分 \u0026quot;schemeful same-site\u0026quot;) same-origin none  Reference  Understanding \u0026quot;same-site\u0026quot; and \u0026quot;same-origin\u0026quot; ","link":"https://sharonwu0505.github.io/docs/2021/same-site-and-same-origin/","title":"Same-Site and Same-Origin"},{"body":"開發時，經常會須要從另一台機器連接在 localhost 的網站，或是希望能有個 public URL 測試某些功能，例如：Facebook Open Graph 設置、Chatbot 連接、金流串接。這時就會想有沒有什麼比先部署到伺服器上再 debug 更方便的作法呢？\n有的，你可用 Ngrok！\nNgrok 是一個能將你的 localhost 網址對應到公開 http/https 連結的服務。背後的原理是 Ngrok 建立了一個 TCP 層上的 tunnel（本機內網和 Ngrok 雲端伺服器之間），處理需求轉發至你指定的 port。\n使用  Getting Started - Setup\n  Step 1: 註冊 Ngrok 帳號 Step 2: 安裝 Ngrok Step 3: 連結帳戶（Ngrok 會給你 access token） Step 4: 指定 port 開始使用，例如：  ./ngrok http 80  啟用後便可以看到連線資料 須注意每次拿到的連結都會不同  進階方案  Pricing\n Ngrok 也有個付費方案，提供客製 domain、每分鐘更多連線數、TLS tunnel 等服務。\n","link":"https://sharonwu0505.github.io/docs/2021/ngrok-intro/","title":"Introduction to Ngrok"},{"body":"","link":"https://sharonwu0505.github.io/tags/tools/","title":"Tools"},{"body":"","link":"https://sharonwu0505.github.io/tags/github-actions/","title":"GitHub Actions"},{"body":"","link":"https://sharonwu0505.github.io/tags/hugo/","title":"Hugo"},{"body":"接續以 Hugo 建立部落格，Hugo 在其文件中提到了多種 Hosting and Deployment 方式。若你選擇將 source code 放在 GitHub 上，那麼你可以直接考慮將部落格放在 GitHub Pages 上，並使用 GitHub Actions 自動化所有部署和更新的流程。\nStep 1: Create a Project on GitHub for the Blog 在 GitHub 上建立部落格 repository，並將 source code 都推上去。\n不該推的東西請加到 .gitignore 中\n resources .DS_Store  Step 2: 建立 GitHub Pages 如果你想建立 GitHub Pages，請按照說明在帳號下建立一個名為 your-username.github.io 的 repository。\nStep 3: 部署準備 Create GitHub token 在 GitHub Tokens Page 建立 personal access token，權限選擇 repo 和 workflow。建立完成後，請複製 token。\nAdd Access Token as Secrets 在部落格 repo 的 Settings \u0026gt; Secrets 頁面上，建立一 Repository secrets。\n Name: 可取你想要的 Value: 貼上剛剛複製的 token  Step 4: Create A GitHub Action  在部落格 repo 建立 .github/workflows 資料夾 資料夾下新增 main.yml，貼上以下 action 設置  1name:CI2on:push3jobs:4deploy:5runs-on:ubuntu-18.046steps:7- name:Git checkout8uses:actions/checkout@v2910- name:Update theme11# (Optional) If you have the theme added as submodule, you can pull it and use the most updated version12run:git submodule update --init --recursive1314- name:Setup hugo15uses:peaceiris/actions-hugo@v216# or change to a version you prefer17with:18hugo-version:\u0026#34;0.80.0\u0026#34;1920- name:Build21# remove --minify tag if you do not need it22# docs: https://gohugo.io/hugo-pipes/minification/23run:hugo --minify2425# replace TOKEN and username to your own settings26- name:Deploy27uses:peaceiris/actions-gh-pages@v328with:29personal_token:${{ secrets.TOKEN }}30external_repository:\u0026lt;username\u0026gt;/\u0026lt;username\u0026gt;.github.io31publish_dir:./public32# keep_files: true33user_name:\u0026lt;username\u0026gt;34user_email:\u0026lt;username@email.com\u0026gt;35publish_branch:main36# cname: example.comStep 5: Push to GitHub Remote push 到 remote 後，你將會在 repo 的 Actions 頁面看到 action 的進度。等待 action 成功後，就可以在 https://\u0026lt;username\u0026gt;.github.io/ 看到部落格囉！\n Reference  GitHub Actions Hugo: Deploy Static Site using GitHub Actions ","link":"https://sharonwu0505.github.io/docs/2021/deploy-hugo-blog-to-github/","title":"自動化部署 Hugo 部落格到 GitHub Pages"},{"body":"Hugo 是一個用 Go 寫成的靜態網站生成器（Static Site Generator）。其架構允許以 Markdown 格式撰寫內容，再搭配 layout template 渲染出畫面，對於喜歡用 Markdown 簡潔撰寫文章的人來說很合適！\n就讓我們來看看如何以 Hugo 建立部落格，並在每次更新後自動化部署到 GitHub Pages。\nHugo 不管是「網站打包」還是「從零建立網站」的速度都很快，號稱\n The world’s fastest framework for building websites.\n 與類似的框架 Wordpress 和 Gatsby 一樣，Hugo 也有豐富多元且開源的主題 (theme)，讓人方便快速地就建立起自己的網站。\n此網站就是以 Hugo 建立的，並使用 Compose Theme 讓我們來看看是怎麼做的吧～\nGetting Started  Reference: Hugo - Quick Start, Compose - Install Theme\n  Step 1 - Install Hugo (for MacOS)  brew install hugo  Step 2 - New a Site  hugo new site my-blog  Step 3 - Install a theme  cd my-blog git init git submodule add https://github.com/onweru/compose/ themes/compose cp -a themes/compose/exampleSite/* .  Step 4 - Run Hugo Server  hugo server   Step 5 - Open http://localhost:1313/ in browser and then you'll see a site with the Compose theme\n  Step 6 - Add your content and customize the styles!\n  Directory Structure Hugo 有制式的檔案架構，若依照該架構放置內容，便能享有 Hugo 預設的功能，諸如：列表 (list page) 和單篇 (single page) 結構、多國語言、template 組合等等。以下介紹常見 Hugo 架構中各檔案夾的意義。\nmy-blog ├── archetypes ├── assets // scss and js to be processed by Hugo Pipes ├── content // 網站主要內容都維護在此 ├── layouts // 網站頁面樣式，因為我們有使用主題，如果需要客製化覆蓋主題的樣式，可在此新增檔案 ├── static // 放置網站圖片、CSS、JS 檔案 ├── theme // 主題 └── config.toml // 設定檔  Layout 覆蓋順序請見 Hugo's Lookup Order\n Deploy 請見下篇自動化部署 Hugo 部落格到 GitHub Pages\n","link":"https://sharonwu0505.github.io/docs/2021/build-a-blog-with-hugo/","title":"以 Hugo 建立部落格"},{"body":"","link":"https://sharonwu0505.github.io/tags/webview/","title":"WebView"},{"body":"本篇文章預計介紹什麼是 WebView，以及 Frontend 使用 WebView 時可能會遇到的問題。\nA WebView is an embeddable browser that a native application can use to display web content.\nConcepts  embeddable browser: WebView is developed based on engines used by common browsers such as Safari, Chrome, Firefox, Edge. It can just be viewed as a browser. native application: apps/games in our case display web content  commonly load web content from a http:// or https:// location JavaScript running inside the WebView also has the ability to call native system APIs.    常見的 WebView 應用  Facebook/Twitter/Line 的內建瀏覽器 App 內嵌入廣告（類似 Web 嵌入 iframe）  Why use WebView?  有助於 app 留存和 UX（不必跳出 app） 更新彈性較高：修改頁面 layout 或邏輯，只需修改網頁後重新部署。不須以推新版本，並要求使用者更新 app 的方式進行  Possible problems  瀏覽器支援程度  無法使用 alert(), confirm() 等，要以 WebChromeClient override methods (ref)   開發環境  比照一般網頁的開發方式 如果想看實際在 app 中開啟狀況，還是得將 app 以模擬器跑起來   UX 問題  WebView 的關閉按鈕可能會跟網頁設計的排版衝突 scroll、touch move 等事件，不一定和瀏覽器的效果相同，ex: scroll bouncing   能否判斷網頁是否是以 WebView 開啟？  判斷 user agent (ref) 保險一點 app 開 WebView 時設定 user agent   身份驗證流程，ex: token 存取，也涉及 UX  連接和 App 相同的伺服器？ 視為 App 的延伸並從 App 獲取部分資料？    References  https://www.kirupa.com/apps/webview.htm https://docs.uniwebview.com/ 查 WebView 大多都是 app 相關的開發文章，事實上使用 WebView 的話，frontend 也不太需要做什麼處理 ","link":"https://sharonwu0505.github.io/docs/2021/what-is-webview/","title":"What is WebView?"},{"body":"","link":"https://sharonwu0505.github.io/tags/optimize-images/","title":"Optimize Images"},{"body":"本篇將介紹兩種常見的圖片優化方式，分別是使用 WebP 格式和 lazy loading，適時地採用這些方法可以提升網站效能。\n方法一：使用 WebP 格式減少圖片載入時間 WebP 是 Google 在 2010 年釋出的圖片格式，和傳統的 JPEG 格式相比之下檔案更小，同時能兼顧影像品質。\n JPEG 2000, JPEG XR, and WebP are image formats that have superior compression and quality characteristics compared to their older JPEG and PNG counterparts. Encoding your images in these formats rather than JPEG or PNG means that they will load faster and consume less cellular data. (from web.dev)\n 瀏覽器支援度 根據 Can I Use 的資料，WebP 除了 IE 和 Safari，大部分瀏覽器已經支援，其支援度較 JPEG 2000 和 JPEG XR 高上許多。\n轉換圖片為 WebP 格式  Convertio：線上轉檔服務，不過要注意檔案大小限制 File Format plugin by Telegraphics：PhotoShop 的外掛，不確定新版 PhotoShop CC 能不能使用 cwebp Encoder：Google 官方的 command line utility imagemin-webp：npm 套件，要寫一小段 script  Webp 轉換套件眾多，可再依照需求挑選。\n在 HTML 使用 WebP 圖片 1\u0026lt;picture\u0026gt; 2 \u0026lt;source srcset=\u0026#34;image.webp\u0026#34; type=\u0026#34;image/webp\u0026#34;\u0026gt; 3 \u0026lt;!-- 可多寫幾個 source，瀏覽器讀取的順序是由上而下，直到遇見支援的格式為止 --\u0026gt; 4 \u0026lt;img src=\u0026#34;fallback.jpg\u0026#34; alt=\u0026#34;fallback圖片\u0026#34;\u0026gt; 5\u0026lt;/picture\u0026gt; 在 CSS 使用 WebP 圖片  要透過 JavaScript 去偵測瀏覽器能不能正常讀取 WebP 圖片，作法是實際載入一張 WebP 圖，然後根據載入成功與否，加上對應的 classes 可以選擇用第三方套件，例如 Modernizr，或自己手寫  1.webp .div-with-background { 2 background-image: url(\u0026#34;image.webp\u0026#34;); 3} 4 5.no-webp .div-with-background { 6 background-image: url(\u0026#34;fallback.jpg\u0026#34;); 7} 方法二：透過 Lazy Loading 延遲載入圖片 Lazy loading 的概念是：網頁在瀏覽時只載入一開始所需的圖片，其餘圖片在後續滾動到畫面時才載入。\nNative Lazy Loading 目前這項功能在瀏覽器上應沒有預設開啟，必須由使用者手動啟用。\n 啟用功能：打開 Chrome 後到網址輸入 chrome://flags，接著搜尋 lazy，再啟用這功能：Enable lazy image loading (#enable-lazy-image-loading) 使用方法：在 HTML 的 img tag 加上 loading=\u0026quot;lazy\u0026quot;  1\u0026lt;img src=\u0026#34;my-image.jpg\u0026#34; loading=\u0026#34;lazy\u0026#34;\u0026gt;  支援程度：0% (from Can I Use)  現行常見作法  方法一：使用第三方套件（例如 lazysizes、Lozad.js） 方法二：監聽 scroll、resize 和 orientation-change 事件 (not suggested)  scroll event 只要使用者滑一下就會排山倒海地觸發，很容易導致效能問題 通常會搭配 debouncing 或 throttling 去抑制觸發的次數或頻率，但又導致程式碼太複雜   方法三：使用 Intersection Observer API（支援度不錯）  實作 Lazy Loading 之步驟（以使用 Intersection Observer API 為例）  不讓圖片正常載入：先將圖片 URL 放在 data-src  1\u0026lt;!-- 無法正常載入的圖片 --\u0026gt; 2\u0026lt;img class=\u0026#34;img lazy\u0026#34; data-src=\u0026#34;cat.jpg\u0026#34;\u0026gt;  監視圖片元素，判斷它們是否進入到畫面中（倚賴 Intersection Observer API）  首先創造一個 Intersection Observer instance 傳入一個 callback function 參數，等偵測到元素進入畫面時 callback function 會被呼叫 使用 instance 的 observe method 開始監視元素   元素進入畫面後，再載入圖片  判斷目標元素是否進入畫面 確認目標進入畫面後，把 data-src 的值取出，放到 src 以顯示圖片   使用 observer.unobserve 取消監視元素  1// callback function parameter for observer 2function onEnterView(entries, observer) { 3 for (let entry of entries) { 4 if (entry.isIntersecting) { 5 // 監視目標進入畫面 6 const img = entry.target 7 img.setAttribute(\u0026#39;src\u0026#39;, img.dataset.src) // 把值塞回 src 8 img.removeAttribute(\u0026#39;data-src\u0026#39;) 9 observer.unobserve(img) // 取消監視 10 } 11 } 12} 13 14const watcher = new IntersectionObserver(onEnterView) 15const lazyImages = document.querySelectorAll(\u0026#39;img.lazy\u0026#39;) 16for (let image of lazyImages) { 17 watcher.observe(image) // 開始監視 18} ","link":"https://sharonwu0505.github.io/docs/2021/optimize-images/","title":"Optimize Images for Web Performance"},{"body":"","link":"https://sharonwu0505.github.io/tags/performance/","title":"Performance"},{"body":"","link":"https://sharonwu0505.github.io/tags/prettier/","title":"Prettier"},{"body":"Prettier is an opinionated code formatter supporting several languages. The biggest reason for adopting Prettier is to stop all the on-going debates over styles. Therefore, applying Prettier to frontend development flow can save much time on formatting codes and align coding styles.\nIn my opinion, ESLint and Prettier are must tools for every frontend projects (not only personal, but also group ones).\nPrettier vs. Linters Linters have two categories of rules:\n Formatting rules: eg: max-len, no-mixed-spaces-and-tabs, keyword-spacing, comma-style, … Code-quality rules: eg: no-unused-vars, no-extra-bind, no-implicit-globals, prefer-promise-reject-errors, …  Prettier covers all needs of formatting codes, but it does nothing with checking code qualities. In other words, use Prettier for formatting and linters for catching bugs!\nUsage Global Settings  Install: npm install -g prettier@2.2.1  should lock the version, because default rules differ by releases check the version: npm list -g prettier   Create a .prettierrc file  cd (to root path) touch .prettierrc   Add rules to ~/.prettierrc  open the file: open ~/.prettierrc add following lines and save it    { \u0026quot;printWidth\u0026quot;: 100, \u0026quot;tabWidth\u0026quot;: 2, \u0026quot;semi\u0026quot;: true, \u0026quot;trailingComma\u0026quot;: \u0026quot;es5\u0026quot;, \u0026quot;jsxBracketSameLine\u0026quot;: true }  (optional) Create a .prettierignore file Format certain files: prettier --write ${file-path-or-pattern}  Integrate with VSCode  Install Prettier - Code formatter plugin (is using prettier@2.2.1) Open settings.json, add following lines and save it Format current file: cmd+shift+p \u0026gt; Format Document  For Prettier \u0026quot;editor.defaultFormatter\u0026quot;: \u0026quot;esbenp.prettier-vscode\u0026quot;, \u0026quot;editor.formatOnSave\u0026quot;: true, // default Other Settings \u0026quot;editor.rulers\u0026quot;: [ 100 ], \u0026quot;editor.tabSize\u0026quot;: 2, // optional \u0026quot;editor.renderWhitespace\u0026quot;: \u0026quot;boundary\u0026quot;, // recommended \u0026quot;javascript.updateImportsOnFileMove.enabled\u0026quot;: \u0026quot;always\u0026quot;, // recommended Local Settings by Projects If a project has its own Prettier config file, the configuration will be applied. Prettier searches recursively up the file path, it will fallback to global settings if local configuration is not found.\nConfiguration  See options  References  https://prettier.io/ https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode https://hackmd.io/@chupai/HkNT0IMhr ","link":"https://sharonwu0505.github.io/docs/2020/setting-prettier/","title":"Setting Prettier to Format Codes"},{"body":"","link":"https://sharonwu0505.github.io/tags/workflow/","title":"Workflow"},{"body":"","link":"https://sharonwu0505.github.io/tags/eslint/","title":"ESLint"},{"body":"Linting tools like ESLint allow developers to discover problems with their JavaScript code without executing it.\n讓我們來談談如何以 ESLint 改進前端開發流程，且如何挑選 ESLint。\nESLint can\n To find code problems To find patterns that doesn’t adhere to style guides Integrate with editors and CI pipeline to auto-check  More ESlint can do\n Customize linting rules Fix many problems automatically  What is the difference between linters and prettier?\n See Setting Prettier to Format Codes  Select Guides Must have  eslint:recommended plugin:react/recommended  More rules selected  Best practices  [error] default-case [error] default-case-last (for version \u0026gt;= 7.0) [error] default-param-last (conflicts with Redux reducer) [warn] eqeqeq [warn] no-empty-function [warn] no-extra-bind   Stylistic issues  [warn] max-depth: 4 [warn] max-len: 100 [warn] no-multiple-empty-lines: max 2 lines [warn] no-trailing-spaces: ignore comments   React  [error] react/no-access-state-in-setstate   React Hook  [error] react-hooks/rules-of-hooks [warn] react-hooks/exhaustive-deps     Integrate with React Projects Integrating ESLint with React project helps us to find problems and stick to coding guidelines.\nInstallation  If you used create-react-app to start a project, ESLint is already provided. It's highly recommended to extend the default configuration.  Install eslint-plugin-react and eslint-plugin-react-hooks Add .eslintrc and customize settings    Customize ESLint Configuration for Project Bootstrapped by Create-React-App  Step 1: extend ESlint  run touch .env at project root add EXTEND_ESLINT=true to .env   Step 2: install React related ESlint config  run npm install eslint-plugin-react --save-dev run npm install eslint-plugin-react-hooks --save-dev   Step 3: set .eslintrc  run touch .eslintrc at project root remove \u0026quot;eslintConfig\u0026quot; settings in package.json add the following to the file    { \u0026quot;env\u0026quot;: { \u0026quot;browser\u0026quot;: true, \u0026quot;commonjs\u0026quot;: true, \u0026quot;es2020\u0026quot;: true, \u0026quot;node\u0026quot;: true }, \u0026quot;extends\u0026quot;: [ // \u0026quot;react-app\u0026quot;, // will cause cannot find eslint error \u0026quot;eslint:recommended\u0026quot;, \u0026quot;plugin:react/recommended\u0026quot; ], \u0026quot;parserOptions\u0026quot;: { \u0026quot;ecmaFeatures\u0026quot;: { \u0026quot;jsx\u0026quot;: true }, \u0026quot;ecmaVersion\u0026quot;: 11, \u0026quot;sourceType\u0026quot;: \u0026quot;module\u0026quot; }, \u0026quot;plugins\u0026quot;: [ \u0026quot;react\u0026quot;, \u0026quot;react-hooks\u0026quot; ], \u0026quot;rules\u0026quot;: { \u0026quot;default-case\u0026quot;: \u0026quot;error\u0026quot;, \u0026quot;eqeqeq\u0026quot;: \u0026quot;warn\u0026quot;, \u0026quot;no-unused-vars\u0026quot;: [\u0026quot;warn\u0026quot; , { \u0026quot;vars\u0026quot;: \u0026quot;all\u0026quot;, \u0026quot;args\u0026quot;: \u0026quot;after-used\u0026quot;, \u0026quot;argsIgnorePattern\u0026quot;: \u0026quot;^_\u0026quot; }], \u0026quot;no-empty-function\u0026quot;: \u0026quot;warn\u0026quot;, \u0026quot;no-extra-bind\u0026quot;: \u0026quot;warn\u0026quot;, \u0026quot;max-depth\u0026quot;: \u0026quot;warn\u0026quot;, \u0026quot;max-len\u0026quot;: [ \u0026quot;warn\u0026quot;, { \u0026quot;code\u0026quot;: 100 } ], \u0026quot;no-multiple-empty-lines\u0026quot;: \u0026quot;warn\u0026quot;, \u0026quot;no-trailing-spaces\u0026quot;: [ \u0026quot;warn\u0026quot;, { \u0026quot;ignoreComments\u0026quot;: true, \u0026quot;skipBlankLines\u0026quot;: true } ], \u0026quot;react/no-access-state-in-setstate\u0026quot;: \u0026quot;error\u0026quot;, \u0026quot;react-hooks/rules-of-hooks\u0026quot;: \u0026quot;error\u0026quot;, \u0026quot;react-hooks/exhaustive-deps\u0026quot;: \u0026quot;warn\u0026quot; } } 備註  We hide react-app in extends and set eslint:recommended by ourselves. If the settings do not work  delete node_modules run npm install again   若沒有使用 React Hook，不必加上 Hook 相關的 lint   Integrate with VSCode  Install extension ESLint Add following lines to VSCode settings.json  \u0026quot;eslint.lintTask.enable\u0026quot;: true, \u0026quot;eslint.workingDirectories\u0026quot;: \u0026quot;./\u0026quot;, // based on your project structure  References  Popular style guides and ESlint config  Airbnb JavaScript Style Guide（較嚴謹）  eslint-config-airbnb   Google JavaScript Style Guide Javascript Standard Style（較寬鬆）   ","link":"https://sharonwu0505.github.io/docs/2020/setting-eslint/","title":"Setting ESLint to Enhance Frontend Development"},{"body":"","link":"https://sharonwu0505.github.io/tags/react/","title":"React"},{"body":"在寫 React component 時會須要確認 props 是否符合型別和資料結構，以確保 component 能如預期運作。除了用 Flow 或 TypeScript 去檢查型別之外，React 本身也提供 propTypes 屬性用以檢查拿到的 props。在 function 和 class component 上都可以使用。\n不只上述好處，個人認為定義 propTypes 也能讓 component 的 interface 更為清楚，使其他開發者一眼就知道該傳入的 props，有類似文件的作用。\n以下內容大多翻譯自 React 文件：Typechecking With PropTypes\n 須注意為了避免效能問題，propTypes 檢查只發生在開發模式。 如果發生錯誤，會在 console 中看到警告\n Install props-types 自 React v15.5 後，React.PropTypes 被移出到獨立的 library，因此若要使用須額外安裝。\nnpm install prop-types --save Supported PropTypes  Basic data types  PropTypes.any PropTypes.bool  PropTypes.number PropTypes.string  PropTypes.func PropTypes.array PropTypes.object PropTypes.symbol   Renderable types  PropTypes.node : the prop should be anything that can be rendered by React  PropTypes.element: the prop should be a React element   也有其他更精確的 operator 可以用，亦能傳入 expression  instanceOf oneOf oneOfType arrayOf shape   有能定義是否為 required  isRequired    Example (同理 function component) 1import PropTypes from \u0026#34;prop-types\u0026#34;; 2 3class ReactComponent extends React.Component { 4 // ...component class body here 5} 6 7ReactComponent.propTypes = { 8 // ...props-type definitions here 9} Default Prop Values 也可以給予 props defaultProps。型別檢查會在 defaultProps 賦予 props 值之後，所以型別檢查也會作用在 defaultProps 上。\n1class ReactComponent extends React.Component { 2 render() { 3 return ( 4 \u0026lt;div\u0026gt;Hello, {this.props.name}\u0026lt;/div\u0026gt; 5 ) 6 } 7} 8 9ReactComponent.defaultProps = { 10 name: \u0026#34;stranger\u0026#34;, 11} Reference  PropTypes in React: A complete guide ","link":"https://sharonwu0505.github.io/docs/2020/react-props-types/","title":"Validating React Component Props with props-types"},{"body":"","link":"https://sharonwu0505.github.io/tags/golang/","title":"Golang"},{"body":"Go or called GoLang is an open source programming language that makes it easy to build simple, reliable, and efficient software.\nIn this post, we'll talk about how to install Golang and set its workplace. Also, sub directories under the workplace are introduced.\nInstall Go  For MacOS, using Homebrew  brew install go Set Go Workplace  A workspace is Go’s way to facilitate project management.\n  A workspace in nutshell, is a directory on your system where Go looks for source code files, manages dependency packages and build distribution binary files. You can have as many workspaces as you want, as long as you keep GOPATH environment variable pointed to current working workspace directory.\n  Reference: Getting started with Go\n Default Workplace $HOME/go Customize Your Go Workplace Permanently  bash  open file: open ~/.bash_profile edit file: add export GOPATH=$HOME/\u0026lt;customized-path\u0026gt;/go to the file reload: source ~/.bash_profile   zsh  open file: open ~/.zshrc edit file: add export GOPATH=$HOME/\u0026lt;customized-path\u0026gt;/go to the file reload: source ~/.zshrc   others  see SettingGOPATH    Temporarily  For MacOS  see Setting up Environment Variables in MacOS Sierra     Sub Directories under a Go Workplace src  Containing packages (also packages installed by go get command) Whenever working with a new Go project, a new directory for the project should be created under $GOPATH/src.  pkg  Containing Go package objects, which are compiled version of original package source code When a Go program hits import statement, Go looks for the followings in order.  pre-compiled package object corresponded packages in $GOPATH/src corresponded packages in $GOROOT/src    bin  Containing binary executable files for executing Go programs, which are created by go install commands $GOBIN is an environment variable that Go uses to put binary files. By default, $GOBIN is $GOPATH/bin but you can change it, too. ","link":"https://sharonwu0505.github.io/docs/2020/install-and-set-go/","title":"Install Golang and Set Go Workplace"},{"body":"之前遇到 網頁各語言有各自 open graph 設定 的需求，所以決定寫一篇文章介紹什麼是 open graph，以及紀錄 Single Page Application (SPA) 如何實現多國語言之 og tag 設置。\nThe Open Graph Protocol  The Open Graph protocol enables any web page to become a rich object in a social graph. For instance, this is used on Facebook to allow any web page to have the same functionality as any other object on Facebook. source: https://ogp.me/\n  OG tags are used to decide how you website looks on SNS. Different SNS (ex: Facebook, Twitter) has its own og rules, but most tags used are the same. To turn your web pages into graph objects, you need to add basic metadata to your page.  我們在 Twitter 張貼連結時會看到附圖、標題、說明等內容，即是 open graph 功能的顯現。\nBasic Metadata   Facebook - A Guide to Sharing for Webmasters Twitter - Cards   Required meta data  og:title: 文章的標題 og:type: 內容的媒體類型 og:image: 用戶分享內容時顯示的圖像網址 og:url: 網頁的標準網址  Optional meta data  og:description: 內容的簡短說明 og:locale: 資源的地區設定 og:locale:alternate og:determiner og:audio og:video  Example 1\u0026lt;meta property=\u0026#34;og:type\u0026#34; content=\u0026#34;article\u0026#34; /\u0026gt; 2\u0026lt;meta property=\u0026#34;og:title\u0026#34; content=\u0026#34;title to show on SNS\u0026#34; /\u0026gt; 3\u0026lt;meta property=\u0026#34;og:description\u0026#34; content=\u0026#34;describe your website\u0026#34; /\u0026gt; 4\u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;thumbnail for website\u0026#34; /\u0026gt; 5\u0026lt;meta property=\u0026#34;og:url\u0026#34; content=\u0026#34;your website\u0026#39;s link\u0026#34; /\u0026gt;  Debug Tools 設置 open graph tag 後，如果想測試，可使用以下 debug tools\n Enter the site URL (should be public URL) to preview share dialog on SNS  Facebook share debugger Twitter card validator     Limitations  Open graph meta tags cannot be altered dynamically and the url of the page is constant regardless of search result. For SPA, all pages are developed from a single index.html file, so all pages share the same og tags.  Solution to Build Multi-languages OG Tags 1. Build multiple static pages for SNS crawlers\n Source: Single Page Applications and Open Graph\n  Create pages only for og crawlers, which only contain og meta data and a script to redirect back to the SPA.  {site_url}/zh.html {site_url}/en.html   Send those pages based on languages when sharing for og crawlers to get og tags.  2. Use Server-Side-Rendering (SSR) or Isomorphic\n React.js with Next.js 大致概念為第一次頁面渲染使用 SSR，後續操作維持 CSR ","link":"https://sharonwu0505.github.io/docs/2020/multi-lang-og-tags/","title":"Building Multi-Languages OG Tags"},{"body":"","link":"https://sharonwu0505.github.io/tags/open-graph/","title":"Open Graph"},{"body":"","link":"https://sharonwu0505.github.io/tags/seo/","title":"SEO"},{"body":"認識 cookie 的筆記。\nCookie  An HTTP cookie (web cookie, browser cookie) is a small piece of data that a server sends to the user's web browser. The browser may store it and send it back with the next request to the same server. It is one of the methods available for remembering stateful information for the stateless HTTP protocol.\n Purposes  Session management: logins, shopping carts, game scores, etc. Personalization: User preferences, themes, etc. Tracking: recording and analyzing user behavior  Limitations and Alternatives  Cookies are sent with every request, so they can worsen performance (especially for mobile data connections). Modern APIs for client storage are the Web storage API (localStorage and sessionStorage) and IndexedDB.   Creating Cookies  Each cookie is a key=value pair. When receiving an HTTP request, a server can send a Set-Cookie header with the response.  HTTP/2.0 200 OK Content-type: text/html Set-Cookie: \u0026lt;cookie-name\u0026gt;=\u0026lt;cookie-value\u0026gt;;\u0026lt;cookie-name\u0026gt;=\u0026lt;cookie-value\u0026gt;  The cookie is usually stored by the browser, and then the cookie is sent with requests made to the same server inside a Cookie HTTP header.  GET /sample_page.html HTTP/2.0 Host: www.example.org Cookie: \u0026lt;cookie-name\u0026gt;=\u0026lt;cookie-value\u0026gt;;\u0026lt;cookie-name\u0026gt;=\u0026lt;cookie-value\u0026gt;  Cookie Keys  Secure HttpOnly SameSite  SameSite=None  The browser will send cookies with both cross-site requests and same-site requests.   SameSite=Strict  The browser will only send cookies for same-site requests (requests originating from the site that set the cookie).   SameSite=Lax  Same-site cookies are withheld on cross-site subrequests, such as calls to load images or frames, but will be sent when a user navigates to the URL from an external site; for example, by following a link.      SameSite Cookie Changes  Chrome 80 released in February 2020 adopted new policy for SameSite to prevent Cross Site Request Forgery (CSRF). ","link":"https://sharonwu0505.github.io/docs/2020/cookie/","title":"Introduction to Cookie"},{"body":"What is npm and nvm?  npm (Node Package Manager)  JavaScript 套件庫管理工具，可以藉由它下載各式各樣的套件   nvm (Node Version Manager)  各套件和專案用的 Node.js 版本不同，而版本間有不相容的問題，導致套件和專案無法順利運行，因此需要版本管理工具 從 nvm 下載/更換 Node.js 和 npm 版本    Install nvm (for MacOS)  Install nvm using Homebrew  brew install nvm  Add nvm command to shell  echo \u0026quot;source $(brew --prefix nvm)/nvm.sh\u0026quot; \u0026gt;\u0026gt; .bash_profile  Reload the bashprofile file  . ~/.bash_profile or\nsource ~/.bash_profile  If using zsh, need to add command to zshrc  open ~/.zshrc Add source ~/.bash_profile to file, which means load all commands under bashprofile   Check if installation is successful  nvm --version \u0026gt; Example output: 0.35.1 or\ncommand -v nvm \u0026gt; output: nvm Install Node.js and npm by nvm  Check available remote version  nvm ls-remote  Install preferred version  nvm install \u0026lt;version\u0026gt;  Use specific version  nvm use \u0026lt;version\u0026gt; \u0026gt; Example output: Now using node v10.17.0 (npm v6.11.3)  See available local versions  nvm list ","link":"https://sharonwu0505.github.io/docs/2020/nvm-and-npm/","title":"Introduction to NVM and NPM"},{"body":"","link":"https://sharonwu0505.github.io/tags/npm/","title":"npm"},{"body":"React proposes Hook in version 16.8. It allows developers to use state and methods in component life cycle without writing class components. Additionally, there is no breaking changes for Hook. It is completely opt-in and 100% backwards-compatible.\nThe following are my notes when learning React Hook.\nMotivation It’s hard to reuse stateful logic between components. Traditional approaches are: render props, higher-order component (HOC), and context\nWe have to restructure components when applying each approach.\nComplex components become hard to understand. Unrelated actions such as fetching data and setting event listeners are written in the same life cycle. Thus, it's hard to split code and logic.\nClasses confuse both people and machines. Writing functions are easier than writing classes.\nIntroduction Hooks are functions that let you “hook into” React state and lifecycle features from function components.\nUsing the State Hook Syntax 1import React, { useState } from \u0026#39;react\u0026#39;; // import the useState Hook from React 2 3function Example() { 4 const [count, setCount] = useState(0); // declare a state variable and a function for updating state 5 6 return ( 7 \u0026lt;div\u0026gt; 8 \u0026lt;p\u0026gt;You clicked {count} times\u0026lt;/p\u0026gt; 9 \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt; 10 Click me 11 \u0026lt;/button\u0026gt; 12 \u0026lt;/div\u0026gt; 13 ); 14} Tips  Use square brackets: const [count, setCount] = useState(0) Use multiple state variables: State variables can hold objects and arrays just fine, so you can still group related data together. However, unlike this.setState in a class, updating a state variable always replaces it instead of merging it.  Using the Effect Hook  A Complete Guide to useEffect\n The Effect Hook lets you perform side effects in function components. useEffect can be thought of as componentDidMount, componentDidUpdate, and componentWillUnmount combined of React class lifecycle.\nEffects Without Cleanup  useEffect by default runs both after the first render and after every update.  1function Example() { 2 const [count, setCount] = useState(0); 3 4 useEffect(() =\u0026gt; { 5 document.title = `You clicked ${count}times`; 6 }); 7} Effects With Cleanup  class component: We typically set up a subscription in componentDidMount, and clean it up in componentWillUnmount. Lifecycle methods force us to split this logic.  1useEffect(() =\u0026gt; { 2 function handleStatusChange(status) { 3 setIsOnline(status.isOnline); 4 } 5 6 ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange); 7 8 // Every effect may return a function that cleans up after it. This lets us keep the logic for adding and removing subscriptions close to each other. 9 return () =\u0026gt; { 10 ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange); 11 }; 12}); Tips  Use multiple effects to separate concerns Effects by default will run on each re-render. We should think of the use case. Optimize performance by skipping effects. 1useEffect(() =\u0026gt; { 2 document.title = `You clicked ${count}times`; 3}, [count]); // Only re-run the effect if count changes  If you want to run an effect and clean it up only once (on mount and unmount), you can pass an empty array ([]) as a second argument. This tells React that your effect doesn’t depend on any values from props or state, so it never needs to re-run.  Rules of Hooks  Only call Hooks at the top level (React relies on the order in which Hooks are called.) Only call Hooks from React functions More rules  Extended Topics  Building Your Own Hooks (should start with use) Hooks API Reference Hooks FAQ  Discussion 與 Redux 的搭配方式  跨多個 container/component 的 state 仍可用 Redux 管理 涉及 state 且需要重用的邏輯可以包成 Hook，例如權限判斷，不再需要使用 HOC, Context（較難寫，也會讓程式碼變複雜） component 可進一步拆分，寫成 function component 搭配 Hook 處理 state，再組裝，以避免過肥的 component  開始使用 Hook  不需要將現存的 class component 轉變為 function component + Hook（by React 官方） 從新功能開始，試用 Hook，並了解原生 Hook, ex: useState, useEffect, useCallback, etc. 的使用方式。  延伸閱讀 Ephemeral State and App State\n Ephemeral state (sometimes called UI state or local state) is the state you can neatly contain in a single widget. State that is not ephemeral, that you want to share across many parts of your app, and that you want to keep between user sessions, is what we call application state (sometimes also called shared state).  source\n","link":"https://sharonwu0505.github.io/docs/2020/react-hooks/","title":"Notes for React Hooks"},{"body":"","link":"https://sharonwu0505.github.io/tags/react-hooks/","title":"React Hooks"},{"body":"","link":"https://sharonwu0505.github.io/categories/","title":"Categories"},{"body":"To Find Frontend, and to Feel!\n","link":"https://sharonwu0505.github.io/","title":"Draw Closer"}]